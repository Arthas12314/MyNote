# 并发编程之美

## 基础篇

### 1.线程基础

#### 线程

* 概念  CPU分配的基本单位

#### 线程启动的三种方式

* 继承Thread
* 实现runnable
* 使用FutureTask
  * 自定义CallerTask类实现Callable接口，放入FutureTask队列中new Thread（）

#### 线程通知与等待

1. wait()

   当一个线程共享变量调用wait，则该进程挂起，直到其他线程调用notify or notifyall or 该线程的interrupt

2. notify()

   唤醒在该共享变量调用wait()挂起的线程，多个挂起则随机唤醒一个

3. notifyall()

#### 等待线程执行结束

* join()

  调用后阻塞主进程，线程执行完毕后才返回

#### 线程睡眠

* sleep()

  暂停执行权，退出CPU资源调度，但依然持有锁

#### 让出CPU资源

* yield()

  调用时让出已有的时间片，非阻塞

#### 线程中断

* interrupt()

  设置调用方法的线程的中断标志

* isInterrupted()

  获取调用该方法对象的线程的中断标志

* Interrupted()

  获取当前执行线程（而不是调用该方法的线程）的中断标志并清除

#### 线程上下文切换

* 保存执行现场，转为就绪，等待
* 时机
  * 被其他线程中断
  * CPU时间片用完处于就绪状态

#### 线程死锁

* 死锁四条件

  * 互斥条件

    单个资源要求独有

  * 请求并持有

  * 不可剥夺条件

  * 环路等待条件

* 如何避免

  * 只能通过破坏请求并持有和环路等待条件

#### 守护线程与用户线程

* JVM在只有守护进程运行时退出
* setDaemon()

#### ThreadLocal

* 内部实现了一个ThreadLocalMap类型的threadLocals变量，存取对应线程的变量
* 不支持继承的变量

* InheritableThreadLocal
  * 可访问父类进程中设置的本地变量
  * 子进程在构造InheritableThreadLocal时复制一份写入自身的Map

### 2.其他基础

#### 概念

* 并行与并发

* 线程安全问题
* 内存内存可见性问题

#### sychronized

* 语义 
  * 将sychronized块内的变量从工作内存清除，线程从主内存中读取数据
* 实现原理
  * Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用
  * Monitor结构
    * Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；
    * EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。
    * RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。
    * Nest:用来实现重入锁的计数。
    * HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。
    * Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁
  * 当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权
  * 锁住方法则方法会标识ACC_SYNCHRONIZED
* sychronized是重量级锁，会导致上下文切换
* **如果一个对象中有两个方法同时被synchronized，则同一个对象，调用这两个方法时，只能同时执行一个**

#### Volatile

* 保证可见性，但不保证原子性
* 原理
  * 对volatile变量写操作时，会在write操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存
  * 对volatile变量读操作时，会在read操作前加入一条load屏障指令，从主内存中读取共享变量
* 使用场景
  * 写入变量时不依赖变量的当前值
  * 读写变量时没有加锁

#### CAS操作

* 由处理器提供boolean compareAndSwapLong(Object obj,long valueOffset,long expect, long update)方法
* ABA问题由JDK的AtomicStampedReference提供给每个类的时间戳解决

#### Unsafe类

* long objectFieldOffset(Field field)

  > 返回指定变量所属类中的内存偏移地址

* int arrayBaseOffset(Class arrayClass)

  > 获取数组中第一个元素的地址

* int arrayIndexScale(Class arrayClass)

  > 获取数组中第一个元素占用的字节

* boolean compareAndSwapLong(Object obj,long offset,long expect,long update)

  > 比较对象obj中偏移量为offset的变量是否与expect相等

JDK1.8增加的

* long getAndSetLong(Object obj,long offste,long update)
* long getAndAddLong(Object obj,long offset long addValue)

#### Java指令重排

* 为保证有序性 happens-before原则
  * 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生书写在后面的操作
  * 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作
  * volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
  * 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
  * 线程启动规则：Thread对象的start() 方法先行发生于此线程的每一个动作
  * 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
  * 线程终结规则：线程中所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，可以通过Thread.isAlive()的返回值检测到线程已经终止执行
  * 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

#### 伪共享

* 多个变量放入了同一个缓存行则，单线程只能操作单个缓存行，则会出现伪共享

#### 锁

* 乐观锁与悲观锁
* 公平锁与非公平锁
  * 公平ReentrantLock pairLock=new ReentrantLock(true)
  * 非公平ReentrantLock pairLock=new ReentrantLock(false)
* 独占锁与共享锁
  * 独占锁是一种悲观锁，任何时候只有一个线程可以获得，如ReentrantLock
  * 共享锁是一种乐观锁，可以由多个进程持有，可以多个进程读取
* 自旋锁
  * 为了解决线程获取锁失败后从用户态切换为内核态传递变量参数被挂起，获得锁时再次切换为内核态唤醒进程，切换开销大
  * 自旋锁未申请到锁时可能多次尝试，参数设置-XX:PreBlockSpinsh设置尝试次数，默认10

## 高级篇



## 实践篇

