## 自动内存管理机制

<img src="..\笔记图片\JVM体系结构图.png" alt="JVM体系结构图" style="zoom: 100%;" />

线程私有的：

* 程序计数器  不会抛OOM
* 虚拟机栈（局部变量表部分
  * 执行时创建栈帧储存局部变量表、操作栈、动态链接、方法出口等
* 本地方法栈 主要是Native方法相关

线程共享的

* Java堆 最大的一块，涉及各类GC算法

* 方法区 储存虚拟机加载的类信息、常量、静态方法、即时编译器编译后的代码等

  * 低版本HotSpot虚拟机未对此区域进行完全的回收导致过内存泄漏

  * 运行时常量池属于方法区的一部分，Class文件除了有类的版本、字段、方法、接口等信息外还有常量池

直接内存：不属于JVM运行时数据区，也不属于JVM规定的JMM

## 垃圾回收与内存分配策略

### 判断对象已“死”的方法

* 引用计数法

* 根搜索算法：（Java C#都在使用

  可作为GC Roots的对象：

  * 虚拟机栈中引用的对象
  * 方法区中的类静态属性引用的对象
  * 方法去中的常量引用的对象
  * 本地方法栈中JNI（即Native方法）引用的对象

四种引用类型

* 强引用，程序代码之中普遍存在的类似Object obj=new Object()，强引用还存在则不进行回收

  我们平常大部分使用的场景都是使用了强引用，比如new创建对象，反射获得一个对象等。

* 软引用描述还有用但非必需的对象，在OOM之前将对其进行回收 SoftReference实现

  这种可用于那种有可能会在创建后使用的对象，不过为了内存消耗会选择使用软引用，比如缓存。

* 弱引用 生存时间仅到下一次垃圾手机发生之前 WeakReference

  弱引用用于生命周期更短的，对内存更敏感的场景中，比如占用内存很大的Map，java api中就提供了WeakHashMap使用，就会是的大Map被及时清理掉。

* 虚引用 回收时得到一个系统通知PhantomReference

  判断一个对象是否被垃圾回收了

回收方法区（或回收HotSpot虚拟机中的永久代

* 废弃常量

* 无用的类

  * 该类的所有实例被回收
  * 加载该类的所有ClassLoader被回收
  * 该类对应的Class对象没有被引用，无法在任何地方通过反射访问该类的方法

  满足以上则**可以但不一定**被回收，而对象则是满足条件就一定会被回收

### 垃圾回收算法

* 标记清除法：效率不高，大量内存碎片
* 复制算法 eden区8，Suvivor1，to1，复制替换时哪个为空则为to，from区to区反转替换
* 标记整理算法 
* 分代收集算法：即新生代用复制算法，对象生存周期长的老年代用标记清楚/整理法

### 垃圾收集器

* Serial收集器：单线程，且需要暂停所有其他进程来进行收集，简单高效，Client模式的VM应用较好

* ParNew收集器：多线程版本的Serial，二以上的多线程下将优于前者，Server模式的VM首选

* Parallel Scavenge收集器 着重于吞吐量（即用户运行时间占比），高吞吐量则CPU

  设置-Xmx最大堆，然后通过MaxGCPauseMillis参数或GCTimeRatio参数设置优化目标，具体调节由VM完成

* Serial Old收集器 用于配合PS收集器或CMS收集器的后备预案

* Parallel Old收集器 使用多线程和标记整理算法 配合PS收集器，用于对吞吐量和CPU资源敏感的场合

* CMS收集器 以获取最短回收停顿时间为目标，应用于互联网站上或B/S系统的服务端上

  * 初始标记->并发标记->重新标记->并发清除
  * 并发收集低停顿
  * 缺点：
    * 对CPU资源敏感
    * 无法处理浮动垃圾，可能出现Concurrent Mode Failure导致另一次Full GC，可**适当**调高-XX CMSInitiatingOccupancyFraction
    * 大量空间碎片，可通过-XX CMSFullGCsBeforeCompaction设置多少次执行一次带压缩整理的Full GC

* G1收集器 基于标记整理，堆分块，维护优先列表选择进行回收

### 内存分配与回收策略

* 大多数情况，对象在Eden区分配，分配失败则MinorGC
* 大对象直接进入老年代
* 长期存活的对象进入老年代，通过-XX:MaxTenuringThreshold=15来设置
* 动态年龄判断，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，则大于等于的部分直接进入老年代
* 空间分配担保，进入老年代的对象是否能够分配，能则MinorGC否则FullGC，其中担保是去平均估计

## 虚拟机执行子系统

### Class类文件的结构

* CAFE BABE标识为Java的Class文件，4字节
* 版本号 4字节
* u2类型数据标识常量池容量计数值
* 访问标志
* 类、父类、接口索引集合
* 字段表集合：描述接口于类中声明的变量
* 方法表集合
* 属性表集合

### 虚拟机类加载机制

* 类加载的时机

  加载->验证->准备->（解析）->初始化->（使用）->卸载

  括号外的部分必须按顺序完成

  VM未规定何时类加载，但规定了必须加载才可完成的初始化

  * 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候、以及调用一个静态方法的时候
  * 使用reflect包的方法堆类进行反射调用的时候，若未初始化，则触发
  * 初始化一个类的时候，若父类没有初始化，则触发父类的初始化
  * 虚拟机启动时，会初始化主类（包含main方法的）

* 类加载的过程

  * 加载

    * 通过一个类的全限定名来获取定义此类的二进制字节流
    * 将这个字节流所代表的静态储存结构转化为方法去的运行时数据结构
    * 在Java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口

  * 验证

    * 文件格式验证

      魔数、版本号、常量池是否有不支持的常量等

    * 元数据验证

      是否有父类、是否继承了不允许被继承的类等Java语言规范检查

    * 字节码验证

      保证字节码指令不会危害虚拟机安全

    * 符号引用验证

      符号引用中通过字符串描述的全限定类是否能找到对应的类

      类、方法、字段和方法的访问性

  * 准备

    准备阶段将类变量（static变量）内存分配，而初始化时值为0，仅当ConstantValue属性（final修饰）时，才直接初始化为给定值

  * 解析

    * 符号引用

      以一组符号来描述所引用的目标，引用的目标不一定已加载至内存中

    * 直接引用

      可以是直接指向目标的指针、相对偏移量或是一个间接定位到目标的句柄，使用后引用的目标必定在内存中存在

    解析动作主要针对类或接口、

    * 类和接口的解析

      非数组类型则将符号引用的全限定名传递给所处类的加载器去加载该类，过程出现异常则加载失败

      为数组则对每个进行以上过程

      若以上未出异常，则

    * 字段解析

      首先，如果字段所属的类或接口本身包含与目标匹配的字段，则返回直接引用；否则若实现接口，将自顶向下递归查找接口及父接口；否则按继承关系搜索其父类；最后若哈找失败则抛出NoSuchFieldError异常，若权限验证失败则IllegalAccessError异常

    * 类方法解析

      首先查找索引对应的是否接口，是则返回异常；进行匹配，成功则正常引用；否则在父类查找并直接引用；否则在实现的接口与父接口中递归查找，找到则抛出AbstractMethodError异常；否则抛出NoSuchMethodError异常

    * 接口方法解析

      首先查找索引对应的是否是类，实则返回异常；进行匹配，成功则直接引用；否则父接口中递归查找；否则查找失败抛出NoSuchMethodError异常

  * 初始化

    此阶段开开始真正执行Java字节码

    * <clinit>()方法收集类中所有的类变量和静态语句块中的语句
    * 父类的<clinit>()方法先执行，子类的<clinit>()页不需要显式的调用父类的方法
    * <clinit>()方法仅用于静态变量或静态代码块
    * 虚拟机负责管理<clinit>()方法的多线程同步问题

* 类加载器

  * 类在由不同的类加载器加载出来后，是两个独立的类，做对象所属检查不会判定为同一个

  * 站在Java虚拟机的角度讲，只存在两种不同的类加载器
    * 启动类加载器C++实现，是虚拟机自身的一部分
    * 所有其他类的加载器

  * 而站在开发人员角度则分为：
    * 启动类加载器： 将JAVA_HOME\lib中的，或者-Xbootclasspath参数所指定的路径中的类库加载到虚拟机内存，无法被Java程序直接引用
    * 扩展类加载器： 负责加载JAVA_HOME\lib\ext中的或者系统变量java.ext.dirs指定的路径中的所有类库，开发者可直接使用
    * 应用程序类加载器 又系统类加载器 程序默认的类加载器

* 双亲委派模型

  当一个类收到了类加载的请求，委派父类加载器去完成，仅当父类加载器无法完成加载时，子加载器才尝试进行加载

### 虚拟机字节码执行引擎

* 运行时栈帧结构

  * 局部变量表

    通过Slot存放数据

  * 操作数栈

  * 动态连接

    将常量池中指向方法的符号引用为参数，一部分类加载阶段或第一次使用时转化为直接引用，为静态解析，另一部分在运行时转化为直接引用，为动态连接

  * 方法返回地址

  动态连接、方法返回地址、附加信息归为栈帧信息

* 方法调用

  * 解析 运行前便确定的调用版本，编译时必须确定的方法调用

    * invokestatic 调用静态
    * invokespecial 调用实例构造器方法、私有方法和父类方法
    * invokevirtual 调用所有的虚方法
    * invokeinterface 调用接口方法，运行时确定实现此接口的对象

    静态、私有、实例构造器、父类方法+final方法为非虚方法，其他均为虚方法

  * 分派

    * 静态分派

      **重载方法的分派规则**

      解析与分派并不是互斥的，static方法重载时可能先解析再静态分派

    * 动态分派

      **继承与实现关系中的方法分派规则**

      invokevirtual指令运行

      1. 找到操作数栈顶的第一个元素所指向的对象那个的实际类型
      2. 如果找到的实际类型与常量池中描述符和简单名称都相符，则访问权限检验，成功则返回直接引用，否则返回IllegalAccessError
      3. 否则按照继承关系堆实际类型的各个父类进行搜索验证
      4. 上述失败则AbstractMethodError

    * 单分派和多分派

      Java的静态分派为多分派机制，而动态分派为单分派类型

    动态分派的实现与C++类似，虚方法表存放着方法的入口地址，若子类没有重写，则入口与父类一致，若重写了，则替换为子类的入口地址

* 字节码执行引擎

  * 解释执行
  * 基于栈的指令集与基于寄存器的指令集
  * 基于栈的解释器执行过程

### 编译期优化~

* Javac编译器

* Java语法糖

  * 泛型与类型擦除

    重载需要方法的描述符不是完全一致

  * 自动装箱、拆箱与遍历循环

  * 条件编译 

    自动消除无法到达的语法分支，或直接编译不通过

### 运行期优化~

* 即时编译器
* 编译优化技术
  * 公共子表达式消除
  * 数组边界检查消除
  * 方法内联
  * 逃逸分析

## 高效并发

### Java内存模型与线程

* 内存模型

  * 主内存和工作内存

  * 内存间交互操作

    * lock 作用于主内存的变量，把一个变量标识为一条线程独占的状态
    * unlock 作用于主内存的变量，把一个锁定的变量释放出来，释放后才可以被其他线程锁定
    * read 作用于主内存的变量，将一个变量的值传输至工作内存中
    * load 作用于工作内存的变量，将read操作从主内存中得到的变量值放入工作内存的变量副本
    * use 作用于工作内存的变量，将工作内存变量的值传递给执行引擎
    * assign 作用于工作内存的变量，将执行引擎收到的值赋给工作内存中对应的变量
    * store 作用于工作内存的变量，将值传送给主内存
    * write 作用于主内存的变量，将store的变量值赋给主内存变量

    Java内存模型规则

    * 不允许read与load、store与write单独出现；即不允许主内存读取工作内存不接受或工作内存写回主内存不接受
    * 不允许assign操作被丢弃 即工作内存变量改变后必须同步改变主内存
    * 不允许线程无原因地将线程的工作内存同步回主内存
    * use与store之前必须经过assign与load，即变量只能再主内存中诞生
    * 一个变量同一时刻只允许一条线程进行lock
    * 对一个变量执行lock，将清空工作内存中此变量的值，使用前，需要重新load或assign
    * 若未被lock不可unlock，且无法unlock其他线程锁住的变量
    * unlock之前，必须先把变量同步回主内存

  * volatile的特殊规则

    * 在工作内存使用V前都必须先从主内存刷新最新的值，use与load、read相关联
    * 工作内存每次修改V后都必须立刻同步回主内存中，即assign与store、write相关联
    * V不会被指令重排序优化，保证代码执行顺序与程序的顺序相同

  * 原子性、可见性与有序性

    * 原子性 八种操作由JMM保证原子性
    * 可见性 volatile sychronized final均可实现可见性

  * 先行发生原则

    * 程序次序规则
    * 管程锁定规则
    * volatile变量规则
    * 线程启动规则
    * 线程终止规则
    * 线程中断规则
    * 对象终结规则
    * 传递性

* Java与线程

  * 线程的实现
    * 内核级线程
    * 用户级线程
    * 混合实现
  * 线程调度
    * 协同式
    * 抢占式（Java使用
  * 状态转换
    * 新建
    * 运行
    * 无限期等待
    * 限期等待
    * 阻塞
    * 结束

### 线程安全与锁优化

> 线程安全：当多个线程访问一个对象时，如果不用考v了这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的

* Java中的线程安全

  * 不可变
  * 绝对线程安全
  * 相对线程安全（大部分的线程安全类
  * 线程兼容
  * 线程对立（避免出现

* 线程安全的实现方法

  * 互斥同步

    * 临界区
    * 互斥量
    * 信号量

    Java常用的互斥同步由synchronized和重入锁ReentrantLock

    Reentrant高级特性

    * 等待可中断：当持有锁的进程长期不释放锁的时候，正在等待的进程可以选择放弃等待改为处理其他事情
    * 公平锁
    * 锁可以绑定多个条件

  * 非阻塞同步

    依赖硬件指令集，例如

    * Test-and-Set
    * Fetch-and-Increment
    * Swap
    * Compare-and-Swap
    * Load-Linked/Store-Conditional（加载链接/条件储存）

  * 无同步方案（对于天生同步的代码

    * 可重入代码
    * 线程本地储存

* 锁优化

  * 自旋锁

  * 锁消除

    编译器运行时对代码加载的无必要同步措施进行消除

  * 锁粗化

    频繁加锁解锁则将锁范围扩展

  * 轻量级锁

    虚拟机对象头MarkWord

    ![虚拟机对象头MarkWord](..\笔记图片\虚拟机对象头MarkWord.png)

  * 偏向锁

    消除数据在无竞争情况下的同步原语，提高运行性能