## 自动内存管理机制

<img src="..\笔记图片\JVM体系结构图.png" alt="JVM体系结构图" style="zoom: 100%;" />

## 自动内存管理机制

### Java内存区域与内存溢出异常

{% asset_img JVM体系结构图.png JVM体系结构图 %}

#### 运行时数据区域

* 线程私有的：
  * 程序计数器  不会抛OOM
    * 通过改变计数器的值执行分支、循环、跳转、线程恢复等基础功能
  * 虚拟机栈（局部变量表部分
    * 执行时创建栈帧储存局部变量表、操作栈、动态链接、方法出口等
  * 本地方法栈 主要是Native方法相关

* 线程共享的

  * Java堆 最大的一块，涉及各类GC算法

    * 新生代

      Eden、From Survivor、To survivor

    * 老年代

  * 方法区 储存虚拟机加载的类信息、常量、静态方法、字段描述、方法描述、即时编译器编译后的代码等

    * JDK1.7后，字符串常量池从方法区移出
    * 低版本HotSpot虚拟机未对此区域进行完全的回收导致过内存泄漏

    * 运行时常量池属于方法区的一部分，编译期生成的字面量和符号引用将在类加载后放入方法区的运行时常量池中，同时运行时也可以向常量池中添加常量，如String类中的intern()方法

#### 直接内存

* 不属于JVM运行时数据区，也不属于JVM规定的JMM

#### Hotspot

* 对象内存布局

  * 对象头

    1. 储存对象自身的运行时数据

       如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳

    2. 类型指针

       指向对象对应的类型

  * 实例数据

    储存程序代码中所定义的各种类型的字段内容

  * 对齐填充

* 对象的访问定位

  * 使用句柄

    在堆中建立句柄池，存储对象实例数据地址和类型数据地址

  * 直接指针

    在堆中对象放置访问类型数据的指针

### 垃圾收集器与内存分配策略

#### 判断对象已“死”的方法

* 引用计数法

* 可达性分析算法

  > 根搜索算法：（Java C#使用

  可作为GC Roots的对象：

  * 虚拟机栈中(栈帧中的本地变量表)引用的对象
  * 方法区中的类静态属性引用的对象
  * 方法中的常量引用的对象
  * 本地方法栈中JNI（即Native方法）引用的对象

* 四种引用类型

  * 强引用

    程序代码之中普遍存在的类似Object obj=new Object()，强引用还存在则不进行回收我们平常大部分使用的场景都是使用了强引用，比如new创建对象，反射获得一个对象等。

  * 软引用

    描述还有用但非必需的对象，在OOM之前将对其进行回收 SoftReference实现这种可用于那种有可能会在创建后使用的对象，不过为了内存消耗会选择使用软引用，比如缓存。

  * 弱引用 

    生存时间仅到下一次垃圾手机发生之前 WeakReference，弱引用用于生命周期更短的，对内存更敏感的场景中，比如占用内存很大的Map，java api中就提供了WeakHashMap使用，就会是的大Map被及时清理掉。

  * 虚引用 

    回收时得到一个系统通知PhantomReference，判断一个对象是否被垃圾回收了

* 被回收的确认

  * 首先通过GC Roots进行可达性分析，如果没有可达的GC Roots，标记为可进行finalize()加入F-Queue，
  * 稍后对F-Queue进行第二次分析，有可达的GC Roots则清除出队列，若没有，进行回收

* 回收方法区（或回收HotSpot虚拟机中的永久代

  * 废弃常量

  * 无用的类

    * 该类的所有实例被回收
    * 加载该类的所有ClassLoader被回收
    * 该类对应的Class对象没有被引用，无法在任何地方通过反射访问该类的方法

    满足以上则**可以但不一定**被回收，而对象则是满足条件就一定会被回收

#### 垃圾回收算法

* 标记清除法：效率不高，大量内存碎片
* 复制算法 eden区8，Suvivor1，to1，复制替换时哪个为空则为to，from区to区反转替换
* 标记整理算法 
* 分代收集算法：即新生代用复制算法，对象生存周期长的老年代用标记清除/整理法

#### HotSpot算法实现

* 枚举根节点
  * 使用OopMap，HotSpot在类加载完成的时候就把对象内各个数据类型计算出来，JIT也会记录栈和寄存器标记引用
* 安全点
  * OopMap可能变化，则在方法调用、循环跳转、异常跳转等位置设置安全点，通过主动式中断
* 安全区域
  * 保证区域内不会发生引用关系变化，任何位置进行GC都是安全的

#### 垃圾收集器

* Serial收集器

  * 单线程，且需要暂停所有其他进程来进行收集，简单高效，Client模式的VM应用较好

* ParNew收集器

  * 多线程版本的Serial，二以上的多线程下将优于前者，Server模式的VM首选

* Parallel Scavenge收集器

  * 着重于吞吐量（即用户运行时间占比），高吞吐量则CPU
  * 设置-Xmx最大堆，然后通过MaxGCPauseMillis参数或GCTimeRatio参数设置吞吐量优化目标，具体调节由VM完成

* Serial Old收集器

  * 用于配合PS收集器或CMS收集器的后备预案

* Parallel Old收集器

  * 使用多线程和标记整理算法 配合PS收集器，用于对吞吐量和CPU资源敏感的场合

* CMS收集器 以获取最短回收停顿时间为目标，应用于互联网站上或B/S系统的服务端上

  * 运行过程
    * 初始标记 STW 标记GC Roots直接关联的对象
    * 并发标记 进行GC Roots Tracing
    * 重新标记 STW 标记因继续运作变动的标记记录
    * 并发清除
  * 并发收集低停顿
  * 缺点：
    * 对CPU资源敏感
    * 无法处理浮动垃圾，可能出现Concurrent Mode Failure导致另一次Full GC，可**适当**调高-XX CMSInitiatingOccupancyFraction进行启动碎片整理
    * 大量空间碎片，可通过-XX CMSFullGCsBeforeCompaction设置多少次执行一次带压缩整理的Full GC

* G1收集器 Garbage-First

  * 特点

    * 并行与并发

      通过并发的方式缩短STW的时间

    * 分代收集

      不必搭配其他收集器，对新创建的和旧的对象采取不同方式，收集效果更好

    * 空间整合

      整体而言看起来采用标记整理法，而在局部两个Region之间采用复制算法，不会产生内存碎片

    * 可预测的停顿

      使用者明确指定时间内垃圾回收不得超过固定ms

  * 执行原理

    * 建立CardTable维护分区，表中每个entry占512byte的空间，对应内存空间改变则标记dirty
    * 每个分区维护Remember Set保证分区内对象没有被其他Region对象引用，指向CardTable对应Entry，可以找到对应的内存区域
    * 

  * 执行流程

    1. 初始标记 类似CMS
    2. 并发标记 类似CMS
    3. 最终标记 记录变动标记到Remember Set
    4. 筛选回收 根据用户配置进行回收

* GC日志

#### 内存分配与回收策略

* 大多数情况，对象在Eden区分配，分配失败则MinorGC
* 大对象直接进入老年代
* 长期存活的对象进入老年代，经历一次MinorGC年龄增加1，通过-XX:MaxTenuringThreshold=15来设置进入老年代的年龄
* 动态年龄判断，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，则大于等于的部分直接进入老年代
* 空间分配担保，进入老年代的对象是否能够分配，能则MinorGC否则FullGC，其中担保是去平均估计

### 虚拟机性能监控与故障处理工具

#### JDK命令行工具

> 调用tool.jar执行

* jps虚拟机进程状况工具
  * 列出正在运行的虚拟机进程并显示虚拟机执行主类名称、以及这些进程的本地虚拟机唯一ID
  * 命令格式
    * jps [options] [hostid]
    * -m 输出传递给main的参数
    * -l 输出主类全名，jar包则带路径
    * -v 输出对应的JVM参数
* jstat虚拟机统计信息监视工具
  * 监视虚拟机各种运行状态信息，显示虚拟机进程中的类装载、内存、垃圾收集、JIT编译等
  * 命令格式
    * jstat [options] [hostid]
    * -class 查看类装载
    * -gc 查看堆状况包括 Eden、两个survivor、老年代、永久代的容量和已用空间等
* jinfo配置信息工具
  * 实时查看和调整虚拟机各项参数，可以查看隐式
  * 命令格式 
    * jinfo [options] pid
    * -flag查看默认配置
* jmap内存映像工具
  * 生成堆转储存快照
  * 命令格式
    * -dump转储快照
    * -finalizerinfo查看F-Queue对象
    * -heap查看堆详细信息
* jhat堆快照分析工具
* jstack堆栈跟踪工具
  * 可以进行死锁执行分析
* HSDIS JIT生成代码反汇编

#### JDK可视化工具

* JConsole
  * 内存监控 相当于jstat
  * 线程监控 相当于jstack
* VisualVM
  * 显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）
  * 监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack） 
  * dump以及分析堆转储快照（jmap、jhat）
  * 方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法
  * 离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈

### 调优案例分析与实战

...

## 虚拟机执行子系统

### Class类文件的结构

* CAFE BABE标识为Java的Class文件，4字节
* 版本号 4字节
* u2类型数据标识常量池容量计数值
* 访问标志
* 类、父类、接口索引集合
* 字段表集合：描述接口于类中声明的变量
* 方法表集合
* 属性表集合

### 虚拟机类加载机制

* 类加载的时机

  加载->验证->准备->（解析）->初始化->（使用）->卸载

  括号外的部分必须按顺序完成

  VM未规定何时类加载，但规定了必须加载才可完成的初始化

  * 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候、以及调用一个静态方法的时候
  * 使用reflect包的方法堆类进行反射调用的时候，若未初始化，则触发
  * 初始化一个类的时候，若父类没有初始化，则触发父类的初始化
  * 虚拟机启动时，会初始化主类（包含main方法的）

* 类加载的过程

  * 加载

    * 通过一个类的全限定名来获取定义此类的二进制字节流
    * 将这个字节流所代表的静态储存结构转化为方法去的运行时数据结构
    * 在Java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口

  * 验证

    * 文件格式验证

      魔数、版本号、常量池是否有不支持的常量等

    * 元数据验证

      是否有父类、是否继承了不允许被继承的类等Java语言规范检查

    * 字节码验证

      保证字节码指令不会危害虚拟机安全

    * 符号引用验证

      符号引用中通过字符串描述的全限定类是否能找到对应的类

      类、方法、字段和方法的访问性

  * 准备

    准备阶段将类变量（static变量）内存分配，而初始化时值为0，仅当ConstantValue属性（final修饰）时，才直接初始化为给定值

  * 解析

    * 符号引用

      以一组符号来描述所引用的目标，引用的目标不一定已加载至内存中

    * 直接引用

      可以是直接指向目标的指针、相对偏移量或是一个间接定位到目标的句柄，使用后引用的目标必定在内存中存在

    解析动作主要针对类或接口、

    * 类和接口的解析

      非数组类型则将符号引用的全限定名传递给所处类的加载器去加载该类，过程出现异常则加载失败

      为数组则对每个进行以上过程

      若以上未出异常，则

    * 字段解析

      首先，如果字段所属的类或接口本身包含与目标匹配的字段，则返回直接引用；否则若实现接口，将自顶向下递归查找接口及父接口；否则按继承关系搜索其父类；最后若哈找失败则抛出NoSuchFieldError异常，若权限验证失败则IllegalAccessError异常

    * 类方法解析

      首先查找索引对应的是否接口，是则返回异常；进行匹配，成功则正常引用；否则在父类查找并直接引用；否则在实现的接口与父接口中递归查找，找到则抛出AbstractMethodError异常；否则抛出NoSuchMethodError异常

    * 接口方法解析

      首先查找索引对应的是否是类，实则返回异常；进行匹配，成功则直接引用；否则父接口中递归查找；否则查找失败抛出NoSuchMethodError异常

  * 初始化

    此阶段开开始真正执行Java字节码

    * <clinit>()方法收集类中所有的类变量和静态语句块中的语句
    * 父类的<clinit>()方法先执行，子类的<clinit>()页不需要显式的调用父类的方法
    * <clinit>()方法仅用于静态变量或静态代码块
    * 虚拟机负责管理<clinit>()方法的多线程同步问题

* 类加载器

  * 类在由不同的类加载器加载出来后，是两个独立的类，做对象所属检查不会判定为同一个

  * 站在Java虚拟机的角度讲，只存在两种不同的类加载器
    * 启动类加载器C++实现，是虚拟机自身的一部分
    * 所有其他类的加载器

  * 而站在开发人员角度则分为：
    * 启动类加载器： 将JAVA_HOME\lib中的，或者-Xbootclasspath参数所指定的路径中的类库加载到虚拟机内存，无法被Java程序直接引用
    * 扩展类加载器： 负责加载JAVA_HOME\lib\ext中的或者系统变量java.ext.dirs指定的路径中的所有类库，开发者可直接使用
    * 应用程序类加载器 又系统类加载器 程序默认的类加载器

* 双亲委派模型

  当一个类收到了类加载的请求，委派父类加载器去完成，仅当父类加载器无法完成加载时，子加载器才尝试进行加载

### 虚拟机字节码执行引擎

* 运行时栈帧结构

  * 局部变量表

    通过Slot存放数据

  * 操作数栈

  * 动态连接

    将常量池中指向方法的符号引用为参数，一部分类加载阶段或第一次使用时转化为直接引用，为静态解析，另一部分在运行时转化为直接引用，为动态连接

  * 方法返回地址

  动态连接、方法返回地址、附加信息归为栈帧信息

* 方法调用

  * 解析 运行前便确定的调用版本，编译时必须确定的方法调用

    * invokestatic 调用静态
    * invokespecial 调用实例构造器方法、私有方法和父类方法
    * invokevirtual 调用所有的虚方法
    * invokeinterface 调用接口方法，运行时确定实现此接口的对象

    静态、私有、实例构造器、父类方法+final方法为非虚方法，其他均为虚方法

  * 分派

    * 静态分派

      **重载方法的分派规则**

      解析与分派并不是互斥的，static方法重载时可能先解析再静态分派

    * 动态分派

      **继承与实现关系中的方法分派规则**

      invokevirtual指令运行

      1. 找到操作数栈顶的第一个元素所指向的对象那个的实际类型
      2. 如果找到的实际类型与常量池中描述符和简单名称都相符，则访问权限检验，成功则返回直接引用，否则返回IllegalAccessError
      3. 否则按照继承关系堆实际类型的各个父类进行搜索验证
      4. 上述失败则AbstractMethodError

    * 单分派和多分派

      Java的静态分派为多分派机制，而动态分派为单分派类型

    动态分派的实现与C++类似，虚方法表存放着方法的入口地址，若子类没有重写，则入口与父类一致，若重写了，则替换为子类的入口地址

* 字节码执行引擎

  * 解释执行
  * 基于栈的指令集与基于寄存器的指令集
  * 基于栈的解释器执行过程

### 编译期优化~

* Javac编译器

* Java语法糖

  * 泛型与类型擦除

    重载需要方法的描述符不是完全一致

  * 自动装箱、拆箱与遍历循环

  * 条件编译 

    自动消除无法到达的语法分支，或直接编译不通过

### 运行期优化~

* 即时编译器
* 编译优化技术
  * 公共子表达式消除
  * 数组边界检查消除
  * 方法内联
  * 逃逸分析

## 高效并发

### Java内存模型与线程

* 内存模型

  * 主内存和工作内存

  * 内存间交互操作

    * lock 作用于主内存的变量，把一个变量标识为一条线程独占的状态
    * unlock 作用于主内存的变量，把一个锁定的变量释放出来，释放后才可以被其他线程锁定
    * read 作用于主内存的变量，将一个变量的值传输至工作内存中
    * load 作用于工作内存的变量，将read操作从主内存中得到的变量值放入工作内存的变量副本
    * use 作用于工作内存的变量，将工作内存变量的值传递给执行引擎
    * assign 作用于工作内存的变量，将执行引擎收到的值赋给工作内存中对应的变量
    * store 作用于工作内存的变量，将值传送给主内存
    * write 作用于主内存的变量，将store的变量值赋给主内存变量

    Java内存模型规则

    * 不允许read与load、store与write单独出现；即不允许主内存读取工作内存不接受或工作内存写回主内存不接受
    * 不允许assign操作被丢弃 即工作内存变量改变后必须同步改变主内存
    * 不允许线程无原因地将线程的工作内存同步回主内存
    * use与store之前必须经过assign与load，即变量只能再主内存中诞生
    * 一个变量同一时刻只允许一条线程进行lock
    * 对一个变量执行lock，将清空工作内存中此变量的值，使用前，需要重新load或assign
    * 若未被lock不可unlock，且无法unlock其他线程锁住的变量
    * unlock之前，必须先把变量同步回主内存

  * volatile的特殊规则

    * 在工作内存使用V前都必须先从主内存刷新最新的值，use与load、read相关联
    * 工作内存每次修改V后都必须立刻同步回主内存中，即assign与store、write相关联
    * V不会被指令重排序优化，保证代码执行顺序与程序的顺序相同

  * 原子性、可见性与有序性

    * 原子性 八种操作由JMM保证原子性
    * 可见性 volatile sychronized final均可实现可见性

  * 先行发生原则

    * 程序次序规则
    * 管程锁定规则
    * volatile变量规则
    * 线程启动规则
    * 线程终止规则
    * 线程中断规则
    * 对象终结规则
    * 传递性

* Java与线程

  * 线程的实现
    * 内核级线程
    * 用户级线程
    * 混合实现
  * 线程调度
    * 协同式
    * 抢占式（Java使用
  * 状态转换
    * 新建
    * 运行
    * 无限期等待
    * 限期等待
    * 阻塞
    * 结束

### 线程安全与锁优化

> 线程安全：当多个线程访问一个对象时，如果不用考v了这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的

* Java中的线程安全

  * 不可变
  * 绝对线程安全
  * 相对线程安全（大部分的线程安全类
  * 线程兼容
  * 线程对立（避免出现

* 线程安全的实现方法

  * 互斥同步

    * 临界区
    * 互斥量
    * 信号量

    Java常用的互斥同步由synchronized和重入锁ReentrantLock

    Reentrant高级特性

    * 等待可中断：当持有锁的进程长期不释放锁的时候，正在等待的进程可以选择放弃等待改为处理其他事情
    * 公平锁
    * 锁可以绑定多个条件

  * 非阻塞同步

    依赖硬件指令集，例如

    * Test-and-Set
    * Fetch-and-Increment
    * Swap
    * Compare-and-Swap
    * Load-Linked/Store-Conditional（加载链接/条件储存）

  * 无同步方案（对于天生同步的代码

    * 可重入代码
    * 线程本地储存

* 锁优化

  * 自旋锁

  * 锁消除

    编译器运行时对代码加载的无必要同步措施进行消除

  * 锁粗化

    频繁加锁解锁则将锁范围扩展

  * 轻量级锁

    虚拟机对象头MarkWord

    <img src="..\笔记图片\虚拟机对象头MarkWord.png" alt="虚拟机对象头MarkWord">

  * 偏向锁

    消除数据在无竞争情况下的同步原语，提高运行性能