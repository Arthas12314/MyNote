# MySQL高级

https://www.cnblogs.com/lyjun/p/11371851.html

# 数据库架构

* 大表的影响 

  * 慢查询
  * 建立索引需要很长时间
  * 修改表结构需要长时间锁表

* 处理数据库中的大表

  * 分库分表把一张大表分成多个小表
    * 分表主键的选择
    * 分表后跨分区数据的查询和统计
  * 大表的历史数据归档 减少前后端业务的影响
    * 归档时间点的选择
    * 如何进行归档

* 事务

  > 事务时数据库系统区别于其他一切文件系统的重要特性之一

  * 原子性

    一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只执行其中的一部分操作

  * 一致性

    一致性是指事务将数据库从一种一致性状态转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中的数据完整性没有被破坏

  * 隔离性

    隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其它事务是不可见的

    * 未提交读(READ UNCOMMITED)（脏读）
    * 已提交读(READ COMMITED) 一般的SQL数据库的级别 （这就是不可重复读）
    * 可重复读(REPEATABLE READ)
    * 可串行化(SERIALIZABLE) 很少用，因为容易锁

  * 持久性

    一旦事务提交，这其所作的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失。

* 大事务 运行时间比较长，操作的数据比较多的事务

  * 锁定太多的数据，造成大量的阻塞和锁超时
  * 回滚时所需的时间比较长
  * 执行时间长，容易造成主从延迟

## 影响性能的几个方面

* 硬件

* 操作系统

  * CentOS 系统参数优化

    影响重大的a tiile优化参数

    * 增加连接数

      ```
      + net.core.somaxconn=65535
      + net.core.netdev_max_backlog=65535
      + net.ipv4.tcp_max_syn_backlog=65535
      ```

    * 加快TCP回收效率

      ```
      + net.ipv4.tcp_fin_timeout=10
      + net.ipv4.tcp_tw_reuse=1
      + net.ipv4.tcp_tw_recycle=1
      ```

    * 缓冲区接受的默认值和最大值

      ```
      + net.core.wmem_default=87380
      + net.core.wmem_max=16777216
      + net.core.rmem_default=87380
      + net.core.rmem_max=16777216
      ```

    * 失效连接所占用TCP系统资源，加快系统回收的效率

      ```
      + net.ipv4.tcp_keepalive_time=120
      + net.ipv4.tcp_keepalive_intvl=30
      + net.ipv4.tcp_keepalive_probes=3
      ```

    * 内存相关的参数

      ```
      + kernel.shmmax=4294967295
      
      Linux 内核参数中最重要的参数之一，用于定义单个共享内存段的最大值。
      
      > 注意：
      
          1. 这个参数应该设置的足够大，以便能在一个共享内存段下容纳下整个
      
          的Innodb缓冲池的大小。
      
          2. 这个值的大小对于64位linux系统，可取的最大值为物理内存值-1byte，
      
          建议值为大于物理内存的一半，一半取值大于Innodb 缓着冲池的大小即可，
      
          可以去物理内存-1byte。
      
      + vm.swappiness=0
      
      这个参数当内存不足时会对性能参数比较明显的影响
      
      Linux系统内存交换区:
      
          在Linux系统安装时都会有一个特殊的磁盘分区，称之为系统交换分区。
      
          使用 free -m 在系统中可以看到类似下面内容其中swap就是交换分区。
      
          当操作系统因为没有足够内存时就会将一些<font color="red">虚拟内存
      
          </font>写到<font color="red">磁盘的交换区</font>中这样就会发生
      
          内存交换
      
      在MySQL服务器上是否要使用交换分区有一些争议:
      
          在MySQL服务所在的Linux系统上完全禁用交换分区。
      
          带来的风险：
      
            1. 降低操作系统的性能
      
            2. 容易造成内存溢出、崩溃，或都被操作系统Kill掉
      
      结论：
      
          在MySQL服务器上保留交换区还是很必要的，但是要控制何时使用交换分区
      
      vm.swappiness=0就是告诉Linux内核除非虚拟内存完全满了，否则不要使用交换区。
      ```

    * 增加资源限制(/etc/security/limit.conf)

      ```
      这个文件实际上是Linux PAM 也就是插入式认证模块的配置文件。
        打开文件数的限制。
        * soft nofile 65535
        * hard nofile 65535
        加到limit.conf 文件末尾就可以了
        *      表示对所有用户有效
        soft    指的是当前系统生效的设置
        hard    表明系统中能设定的最大值
        nofile  表示所限制的资源是打开文件的最大数目
        65535  就是限制的数量
        结论：
          把可打开的文件数量增加到了65535个以保证可以打开足够多的文件句柄。
        注意：
          这个文件的修改需要重启系统才可以生效。
      ```
      
    * 磁盘调度策略(/sys/block/devname/queue/scheduler)
    
      ```
      cat /sys/block/sda/queue/scheduler
      noop anticipatory deadline [cfq]
      noop(电梯式调度策略)
          NOOP实现了一个FIFO队列，它像电梯的工作方法一样对I/O请求进行组织，当
          有一个新的请求到来时，它将强求合并最近的请求之后，以此来保证请求同一
          介质。NOOP倾向饿死读而利于写，因此NOOP对于闪存设备、RAM及嵌入式系统
          是最好的选择。
      deadline(截止时间调度策略) 
          Deadline确保了再一个截止时间内服务请求，这个截止时间是可调整的，而
      默认读期限短语写期限。这样就防止了写操作因为不能被读取而饿死的现象，
          Deadline对数据库类应用是最好的选择。
  anticipatory(预料I/O调度策略)
          本质上与Deadline一样，但在最后一次读操作后，要等6ms，才能继续进行对
      其它I/O请求进行调度。他会在每个6ms中插入行的I/O操作，而会将一些小写
          入流合并成一个大写入流，用写入延时换区最大的写入吞吐量。AS适合于*写
          入较多的环境*，比如文件服务器，AS对数据库环境表现很差。
      ```
      
  
* 数据库存储引擎的选择

* **数据库参数配置**

* 数据库结构设计和SQL语句

## MySQL体系结构

<img src="..\笔记图片\MySQL体系结构.png" alt="MySQL体系结构" style="zoom: 33%;" />

* 客户端
  * PHP\\JAVA\\C API\\.Net\\ODBC\\JDBC

* 存储引擎
  * InnoDB\\MyISAM\\CSV\\Memory\\ARCHIVE\\ExtraDB

#### MyISAM

* 特性
  * 并发性与锁级别（表锁）（读写的话并发性支持不好，只读可以）
  * 表损坏修复（因为不是修复事务，可能会造成数据丢失）
  * MyISAM表支持的索引类型
    - Btree + 全文索引
  * MyISAM表支持数据压缩
    - 命令行：myisampack 且压缩表只读
* 限制
  - 版本< MySQL5.0默认表大小为4G
  - 如存储大表则要修改MAX_Rows 和 AVG_ROW_LENGTH
  - 版本> MySQL5.0时默认支持为256TB
* 使用场景
  - 非事务型应用
  - 只读类应用
  - 空间类应用

#### InnoDB

- MySQL5.5.8及以后的版本默认存储引擎

- Innodb 使用表空间进行 数据存储

  ```css
  innodb_file_per_table 参数
  ON:独立表空间：tablename .ibd
  OFF:系统表空间: ibdataX
  ```

* 系统表和独立表空间要如何选择 推荐使用独立表空间

  * 比较

    * 系统表空间无法简单的收缩文件大小
      独立表空间可以通过optimeize table命令收缩系统文件

    * 系统表空间会产生IO瓶颈
      独立表空间可以同时向多个文件刷新数据

* 把原来存在于系统表空间中的表转移到独立表空间的方法

  1. 使用mysqldump导出所有数据库表数据
2. 停止MySQL服务，修改参数，并删除InnoDB相关文件
  3. 重启MySQL服务，重建Innodb系统表空间
  4. 重新导入数据

* 特性

  * Innodb是一种事务性存储引擎
  * 完全支持事务的ACID特性（原子 一致 隔离 持久）
  * Redo Log（持久性） 和 Undo Log
  * Innodb支持行级锁
  * 行级锁可以最大程度的支持并发
  * 行级锁是由存储引擎层实现的
* 适用场景
  * Innodb适合于大多数的OLTP应用
  * 5.7版本之后支持全文索引和空间函数

#### CSV

* 文件系统
  * 数据以文本方式存储在文件中
  * .CSV文件存储表内容
  * .CSM文件存储表的元数据如表状态和数据量
  * .frm文件存储表结构信息
* 特点
  * 以CSV格式进行数据存储
  * 所有列必须都是不能为NULL
  * 不支持索引，不适合大表，不适合在线处理
  * 可以对数据文件直接编辑 保存文本文件内容
* 适用场景
  * 适合做为数据交换的中间表
    - excel->CSV文件->MySQL数据目录
    - 数据->CSV文件->其他web程序

#### Archive

* 文件系统
  * 以zlib对表数据进行压缩，磁盘I/O更少
  * 数据存储在ARZ为后缀的文件中
* 特点
  * 只支持insert和select操作
  * 只允许在自增ID列上加索引
* 适用场景
  * 日志和数据采集类应用

#### Memory

* 文件系统
  * 也称为HEAP存储引擎，所以数据保存在内存中
  * 重启后表数据丢失，表结构会保留
* 特点
  * 支持HASH索引和BTree索引
    - 等值查找用HASH
    - 范围查找用BTree
  * 所有字段都为固定长度
    - 计算使用varchar(10) 也等于 char(10)
  * 不支持BLOG和TEXT等大字段
  * Memory存储引擎使用表级锁
  * 最大大小由max_heap_table_size参数决定
* 适用场景
  * 用于查找或者是映射表，例如邮编和地区的对应表
  * 用于保存数据分析中产生的中间表
  * 用于缓存周期性聚合数据的结果表
* 与临时表的差别
  * 临时表
    - 系统使用的临时表
      - 超过限制使用myisam临时表
      - 未超限制使用Memory表
    - create temporary table 建立的临时表

#### Federated

* 特点

  * 提供了访问远程MySQL服务器上表的方法
  * 本地不存储数据，数据全部放到远程服务器上
  * 本地需要保存表结构和远程服务器的连接信息

* 默认禁止，启用需要在启动时增加federated参数

  > ```shell
  > mysql://username[:password]@host_name[:port_num]/db_name/tbl_name
  > ```

* 适用场景
  
  * 偶尔的统计分析及手工查询

#### 锁

锁对主要作用是管理共享资源的并发访问，用于实现事务的隔离性

| 写锁         | 读锁   |        |
| ------------ | ------ | ------ |
| 写锁（独占锁 | 不兼容 | 不兼容 |
| 读锁（共享锁 | 不兼容 | 兼容   |

- 表级锁（并发支持不好）
- 行级锁（开销大）

### MySQL服务器参数

* MySQL获取配置信息路径

  * 命令行参数

    mysqlid_safe -- datadir=/data/sql_data

  * 配置文件

    mysqlid --help --verbose | grep -A 1 'Default options'

    /etc/my.cnf /etc/mysql/my.cnf /home/mysql/my.cnf ~/.my.cnf

* MySQL配置参数的作用域

  * 全局参数

    set global 参数名=参数值

    set @@global.参数名:=参数值

  * 会话参数

    set[session]参数名=参数值

    set @@session.参数名:=参数值

* 内存配置相关参数

  * 确定可以使用的内存上限

  * 确定MySQL的**每个连接**使用的内存

    * 排序缓存区的尺寸	sort_buffer_size
    * 每个线程使用连接缓冲区的大小	join_buffer_size
    * MYISAM表进行全表扫描时,所分配的读缓存池的大小	read_buffer_size
    * 控制的是索引缓冲区的大小	read_rnd_buffer_size

  * 确定需要为操作系统保存多少内存

  * 如何为缓存池分配内存

    总内存 - (每个线程所需要的内存*连接数) - 系统保留内存

    * innodb所使用的缓冲池的大小	Innodb_buffer_pool_size

* I/O相关配置参数

  * Innodb_log_file_size

  * Innodb_log_files_in_group

  * 事务日志总大小 = Innodb_log_files_in_group*Innodb_log_file_size

  * Innodb_log_buffer_size

  * Innodb_flush_log_at_trx_commit

    * 0：每秒钟进行一次log写入到操作系统cache,并刷新log到磁盘
    * 1[默认]：每次在事务提交的时候呢,都会执行log写入操作系统cache,并刷新操作系统cache log到磁盘文件持久化的存储的操作
    * 2[建议]：表示事务提交后,执行log数据写入到操作系统cache的这个操作,并且每秒钟执行一次从操作系统的cache刷新到磁盘文件的log操作

  * Innodb刷新的方式 Innodb_flush_method=O_DIRECT

    这个设置会通知操作系统,不要缓存数据,也不要预读,也就是说,这个选项完全关闭了操作系统的缓存,并且使所有读和写呢,都直接通过存储设备,来完成,避免了Innodb和操作系统,对于数据的双重缓存

  * 控制Innodb如何使用表空间 Innodb_file_per_table=1

    为每一个表建立一个单独的表空间,否则就会把所有的Innodb表的数据呢,存储到系统表空间中

  * 控制innodb是否双写缓存 Innodb_doublewrite=1

    避免没有写完整所导致的数据损坏

* 安全相关配置参数

* 其他常用配置参数

### 数据库设计对性能的影响

* 过份的反范式化为表建立太多的列
* 过份的范式化造成太多的表关联
* 在OLTP环境中使用不恰当的分区表
* 使用外键保证数据的完整性

### 性能优化顺序

- 数据库结构设计和SQL语句
- 数据库存储引擎的选择和参数配置
- 系统选择及优化
- 硬件升级

## 基准测试

> 基准测试是一种测量和评估软件性能指标的活动用于建立某个时刻的性能基准，以便当系统发生软硬件变化时重新进行基准测试以评估变化对性能的影响

* 对比

  * 基准测试	直接、简单、易于比较 ，用于评估服务器的处理能力
  * 压力测试    对真实的业务数据进行测试，获得真实系统所能承受的压力

* 目的

  - 建立MySQL服务器的性能基准线
    确定当前MySQL服务器运行情况
  - 模拟比当前系统更高的负载，以找出系统的扩展瓶颈
  - 测试不同的硬件、软件和操作系统配置
  - 证明新的硬件设备是否配置正确

* 常用指标

  * 单位时间内所处理的事务数（TPS）

  * 单位时间内所处理的查询数（QPS）

  * 响应时间

    > 平均响应时间、最小响应时间、最大响应时间、各时间所占百分比

  * 并发量：同时处理的查询请求的数量

    > 并发量不等于连接数

## 数据库结构优化

* 目的
  * 减少数据冗余
  * 尽量避免数据维护中出现更新，插入和删除异常
    * 插入异常：如果表中的某个实体随着另一个实体而存在
    * 更新异常：如果更改表中的某个实体的单独属性时，需要对多行进行更新
    * 删除异常：如果删除表中某一实体则会导致其他实体的消失
  * 节约数据存储空间
  * 节省数据查询效率

### 数据库结构设计的步骤

* 需求分析：全面了解产品设计的存储需求
  - 存储需求
  - 数据处理需求
  - 数据的安全性和完整性
* 逻辑设计：设计数据的逻辑存储结构
  * 数据实体之间的逻辑关系，解决数据冗余和数据维护异常
* 物理设计：根据所使用的数据库特点进行表结构设计
  * 关系型数据库：Oralce，SQLServer，MySQL，postgresSQL
  * 非关系型数据库： mongo,Redis,Hadoop
* 维护优化：根据实际情况对索引、存储结构等进行优化

#### 数据库设计的第一范式

- 数据库表中的所有字段都只具有单一属性
- 单一属性的列是由基本的数据类型所构成的
- 设计出来的表都是简单的二维表

#### 数据库设计的第二范式

- 要求一个表中只有具有一个业务主键

  > 也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系

#### 数据库设计的第三范式

- 每一个非主属性既不部分依赖于也不传递依赖于业务主键

  > 也就是在第二范式的基础上消除了非主属性对主键的传递依赖

###  需求分析及逻辑设计

#### 范式化设计

* 需求

  * 本网站只销售图书类商品
  * 需要具有以下功能
    - 用户登录
    - 用户管理
    - 商品展示
    - 商品管理
    - 供应商管理
    - 在线销售

* 用户登录及用户管理功能

  - 用户必须注册并登录系统才能进行网上交易

     用户名作为业务主键

  - 同一时间一个用户只能在一个地方登录

  - 用户属性：{用户名，密码，手机号，姓名，注册日期，在线状态，出生日期} 用户名为主键

    > 只有一个业务主键，一定是符合第二范式
    >  没有属性和业务主键存在传递依赖关系，符合第三范式
  
* 商品展示和商品管理功能

  * 商品信息:{商品名称，分类名称，出版社名称，图书价格，图书描述，作者}

    > 商户名称和分类名称为主键 不满足第二范式

    - 商品信息：{商品名称，出版社名称，图书价格，图书描述，作者}
    - 分类信息：{分类名称，分类描述}
    - 商品分类（对应关系表）：{商品名称，分类名称}

* 供应商管理功能

  * 供应商信息：{出版社名称，地址，电话，联系人，银行账号} 出版社信息PERMARY KEY

* 在线销售功能

  * 在线销售：{订单编号，下单用户名，下单日期，订单金额，订单商品分类，订单商品名，订单商品单价，订单商品数量，支付金额，物流单号}

    1. 只有一个业务主键，符合第二范式
    2. 订单商品单价，订单商品数量，订单编号 存在着传递关系，不符合第三范式
    3. 数据冗余=>订单商品信息和订单信息表中的数据

  * 拆分

    - 订单表：{订单编号，下单用户名，下单日期，支付金额，物流单号}
    - 订单商品关联表：{订单编号，订单商品分类，订单商品名，商品数量}

  * 编写SQL查询出每一个用户的订单总金额

    ```mysql
    
    select 下单用户名,sum(d.商品价格*b.商品数量) 
    from 订单表 a 
    join 订单商品关联表 b on a.订单编号=b.订单编号 
    join 商品分类关联表 c on c.商品名称=b.商品名称 
    and c.分类名称=b.订单商品分类 
    join 商品信息表 d on d.商品名称=c.商品名称 
    group by 下单用户名
    ```

#### 反范式化设计

> 反范式化是针对范式化而言的，在前面介绍了数据库设计的范式，所谓的反范式化就是为了性能和读取效率的考虑而适当的对数据库设计范式的要求进行违反，而允许存在少量的数据冗余，换句话来说反范式化就是使用空间来换取时间

* 原来的表：
  * 商品信息：{商品名称，出版社名称，图书价格，图书描述，作者}
  * 分类信息：{分类名称，分类描述}
  * 商品分类关系：{商品名称，分类名称}
* 改造后的表
  * 商品信息：{商品名称，分类名称，出版社名称，图书价格，图书描述，作者}
  * 分类信息：{分类名称，分类描述}
* 原来的表：
  * 订单表：{订单编号，下单用户名，下单日期，支付金额，物流单号}
  * 订单商品关联表：{订单编号，订单商品分类，订单商品名，商品数量}
* 改造后的表：
  * 订单表：{订单编号，下单用户名，手机号，下单日期，支付金额，物流单号，订单金额}
  * 订单商品关联表：{订单编号，订单商品分类，订单商品名，商品数量，商品单价}

* 编写SQL查询出每一个用户的订单总金额

  ```mysql
  select 下单用户名,sum(订单金额) 
  from 订单表 group by 下单用户名
  ```

- 编写SQL查询出下单用户和订单详情

  ```mysql
  select a.订单编号, a.用户名, a.手机号, b.商品名称, b.商品单价, b.商品数量 
  from 订单表 a join 订单商品
  ```

* 总结
  - 不能完全按照范式化的要求进行设计
  - 考虑以后如何使用表

#### 范式化与反范式化对比

* 范式化
  * 优点：
    - 可以尽量的减少数据冗余,数据表更新快体积小
    - 范式化的更新操作比反范式化更快
    - 范式化的表通常比反范式化更小
  * 缺点：
    - 对于查询需要对多个表进行关联
    - 更难进行索引优化
* 反范式化
  - 优点：
    - 可以减少表的关联
    - 可以更好的进行索引优化
  - 缺点：
    - 存在数据冗余及数据维护异常
    - 对数据的修改需要更多的成本

### 物理设计

#### 物理设计的内容

- 定义数据库、表及字段的命名规范

  - 数据库、表及字段的命名要遵守**可读性**原则
  - 数据库、表及字段的命名要遵守**表意性**原则
  - 数据库、表及字段的命名要遵守**长名**原则

- 选择合适的存储引擎

  | 存储引擎   | 事务   | 锁粒度               | 主要应用                       | 忌用                     |
  | ---------- | ------ | -------------------- | ------------------------------ | ------------------------ |
  | MyISAM     | 不支持 | 支持并发插入的表级锁 | SELECT,INSERT                  | 读写操作频繁             |
  | MRG_MYISAM | 不支持 | 支持并发插入的表级锁 | 分段归档，数据仓库             | 全局查找过多的场景       |
  | Innodb     | 支持   | 支持MVCC的行级锁     | 事务处理                       | 无                       |
  | Archive    | 不支持 | 行级锁               | 日志记录，只支持insert，select | 需要随机读取，更新，删除 |
  | Ndb        | 支持   | 行级锁               | 高可用性                       | 大部分应用               |

- 为表中的字段选择合适的数据类型

  * 为表中的字段选择合适的数据类型

    * 当一个列可以选择多种数据类型时，应该优先考虑素质类型
    * 其次是日期或二进制类型，最后是支付类型
    * 对于相同级别的数据类型，应该优先选择占用空间小的数据类型

  * 选择合适的整数类型

    | 列类型    | 存储空间 | SINGED                                                       | UNSINGED                           |
    | --------- | -------- | ------------------------------------------------------------ | ---------------------------------- |
    | tinyint   | 1字节    | -128~127 (-27~(27)-1)                                        | 0~255 ((2^8)-1)                    |
    | smallint  | 2字节    | -32768~32767 (-2^15 ~ (2^15)-1)                              | 0~65535 ((2^16)-1)                 |
    | mediumint | 3字节    | -8388608~8388607 (-2^23 ~ (2^23)-1)                          | 0~16777215 ((2^24)-1)              |
    | int       | 4字节    | -2147483648~2147483647 (-2^31 ~ (2^31)-1)                    | 0~4294967295 ((2^32)-1))           |
    | bigint    | 8字节    | -9223372036854775808  ~ 9223372036854775807 (-2^63 ~ (2^63)-1) | 0 ~18446744073709551615 ((2^64)-1) |

  * 选择合适的实数类型

    | 列类型  | 存储空间                             | 是否精确类型 |
    | ------- | ------------------------------------ | ------------ |
    | FLOAT   | 4个字节                              | 否           |
    | DOUBLE  | 8个字节                              | 否           |
    | DECIMAL | 每4个字节存9个数字，小数点占一个字节 | 是           |

  * VARCHAR与CHAR类型的选择

    * varchar类型的存储特点
      1. varchar用于存储边长字符串，只占必要的存储空间
      2. 列的最大长度小于255则只占用一个额外字节用于记录字符串长度
      3. 列的最大长度大于255这要占用两个额外字节用于记录字符串长度
      4. 正因为两个字节记录字符串长度，varchar最大长度为 65535，最大存储字符数量(defalut null 则 65535-2-1=65532，not null 则 65535-2=65533)
    * varchar长度选择
      1. 使用最小的符合需求的长度
      2. varchar(5)和varchar(200)存储 'MySQL' 字符串性能不同
    * varchar适用场景
      1. 字符串列的最大长度比平均长度大很多
      2. 字符串列很少被更新
      3. 使用了多字节字符集存储字符串
    * char类型存储特点
      1. CHAR类型是定长的
      2. 字符串存储在CHAR类型的列中会删除末尾的空格
      3. CHAR类型的最大宽度为255
    * char类型适用场景
      1. CHAR类型适合存储所长度近似的值
      2. CHAR类型适合存储短字符串
      3. CHAR类型适合存储经常更新的字符串列

  * 选择合适的日期类型

    * DATETIME类型
    
      > 以YYYY-MM-DD HH:MM:SS[.fraction] 格式存储日期时间
      >
      >  datetime = YYYY-MM-DD HH:MM:SS
      >
      >  datetime(6) = YYYY-MM-DD HH:MM:SS.fraction(微秒需要datetime(6))
      >
      >  DATETIME类型与时区无关，占用8个字节的存储空间
    >
      >  时间范围1000-01-01 00:00:00到9999-12-31 23:59:59

    * TIMESTAMP类型
    
      > 存储了由格林尼治时间1970年1月1日到当前时间的秒数
      >
      >  以YYYY-MM-DD HH:MM:SS.[fraction]的格式显示，占用4个字节(timestamp(6))
    >
      >  时间范围1970-01-01到2038-01-19
    
      timestamp类型显示依赖于所指定的时区
    
      在行的数据修改时可以自动修改timestamp列的值
    
    * DATE类型的优点
    
      1. 占用的字节数比使用字符串（8字节）、datetime（8字节）、int（4字节）存储要少，使用date类型只需要3个字节
    
      2. 使用Date类型还可以利用日期时间函数进行日期之间的计算
    
         date类型用于保存1000-01-01到9999-12-31之间的日期
    
    * TIME类型
    
      time类型用于存储时间数据，格式为HH:MM:SS
    
  * 注意事项

    * 不要使用字符串类型来存储日期时间数据

       日期时间类型通常比字符串占用的存储空间小

       日期时间类型在进行查找过滤时可以利用日期来进行对比

       日期时间类型还有丰富的处理函数，可以方便的对时期类型进行日期计算

    * 使用INT存储日期时间不如使用TIMESTAMP类型（**存疑待研究**）

- 总结

  - 没有特殊要求推荐使用INNODB
  - 为表中的每个列选择合适的类型
  - 如何选择表的主键
    - 主键应该尽可能的小
    - 主键应该是顺序增长的
  - 增加数据的插入效率
    - Innodb的主键和业务主键可以不同（为了业务主键的唯一性，可以使用唯一索引）
  - 数据库结构
    - 查询性能要求
    - 范式化要求

- 建立数据库架构

### 数据库索引优化

#### B-Tree索引

* 优势
  * 因为文件与数据库都是需要较大的存储——不可能全部存储在内存中，故要存储到磁盘上
  2. 所谓索引，即是快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数(B+树相比B树，其非叶子节点占用更小的空间，可以有更多非叶子节点存放在再内存中，减少大量的IO)
  3. 局部性原理与磁盘预读，预读的长度一般为页(page)的整倍数，(在许多操作系统中，页得大小通常为4k)
  4. 数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，(由于节点中有两个数组，所以地址连续)。而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性
  * B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因

* 特点
  * B-tree索引以B+树的结构存储数据
  * B-tree索引能够加快数据的查询速度
  * B-tree索引更适合进行范围查找
* 用到B-Tree索引的情况
  * 全值匹配的查询
    - order_sn='9876432119900'
  * 匹配最左前缀的查询
    - 联合索引的最左侧的字段有用到就可以用到，索引 index(a,b,c), 当查询条件where a='xxx'  时就可以用到，顺序很重要 where a='xxx' and b='yyy'也可以用到，但 where b='xxx' and c='yyy' and a='zzz' 就用不了了
  * 匹配列前缀查询
    - order_sn like '9876%'
  * 匹配范围值的查询
    - order_sn>'9876432119900' and order_sn <'9876432119999'
  * 精确匹配左前列并范围匹配另外一列
  * 只访问索引的查询

#### Hash索引

* 特点

  * Hash 索引时基于Hash表实现的，只有查询条件精确匹配Hash索引中的所有列时，才能够使用到Hash索引。

    对于Hash索引中的所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是Hash码。

* 限制
  * 如果不是按照索引最左列开始查找，则无法使用索引
  * 使用索引时不能跳过索引中的列
  * NOT IN 和 <> 操作无法使用索引
  * 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引

#### 索引优劣

* 优势
  * 索引大大减少了存储引擎需要扫描的数据量
  * 索引可以帮助我们进行排序以避免使用临时表
  * 索引可以把随机I/O变为顺序I/O
* 劣势
  * 索引会增加写操作的成本
  * 太多索引会增加查询优化器的选择时间

#### 索引优化策略

- 索引列上不能使用表达式或函数

- 前缀索引和索引列的选择性

  ```mysql
  CREATE INDEX index_name ON table(col_name(n));
  # 索引的选择性是不重复的索引值和表的记录数的比值
  ```

- 联合索引

  - 如何选择索引列的顺序
    - 经常会被使用到的列优先
    - 选择性高的列优先
    - 宽度小的列优先

- 覆盖索引

  - 优点：
    - 可以优化缓存，减少磁盘IO操作
    - 可以减少随机IO，变随机IO操作变为顺序IO操作
    - 可以避免对Innodb主键索引的二次查询
    - 可以避免MyISAM表进行系统调用
  - 无法使用覆盖索引的情况
    - 存储引擎不支持覆盖索引
    - 查询中使用了太多的列
    - 使用了双%%号的like查询

* 使用索引扫描来优化排序
  - 通过排序操作
  - 按照索引顺序扫描数据
  - 索引的列顺序和Order By子句的顺序完全一致
  - 索引中所有列的放行（升序，降序）和Order by子句完全一致
  - Order by中的字段全部在关联表中的第一张表中

* 使用索引优化锁
  * 索引可以减少锁定的行数
  * 索引可以加快处理速度，同时也加快了锁的释放
* 索引的维护和优化
  * 删除重复和冗余的索引
    - primary key(id),unique key(id),index(id) -> primary key(id)
    - index(a),index(a,b) -> index(a,b)
    - primary key(id),index(a,id) -> primary key(id),index(a)
  * pt-duplicate-key-checker h=127.0.0.1 查询是否有冗余索引
  * 查找未被使用过的索引


* 更新索引统计信息及减少索引碎片
  - analyze table table_name
  - optimize table table_name

### SQL查询优化

#### 获取有性能问题的SQL

- 通过用户反馈获取存在性能问题的SQL（比较被动）
- 通过慢查日志获取存在性能问题的SQL
- 实时获取存在性能问题的SQL

#### 慢查询日志

* 开销
  * 磁盘IO
    - 顺序写入的，对大部分情况来说可以忽略不计
  * 存储日志所需要的磁盘空间
    - 主要要考虑存储日志所需要的大量的磁盘空间
* 语句
  * slow_query_log 启动停止记录慢查日志
    - ON为开启
    - set global
    - 可以通过脚本定时开关参数
  * slow_query_log_file 制定慢查日志的存储路径及文件
    - 默认情况下保存在MySQL的数据目录中
    - 日志存储和数据存储分开存储
  * long_query_time 制定记录慢查日志SQL执行时间的伐值
    - 默认值为10秒，最低到微秒，如果是100微秒 则要表达为 0.0001
    - 一般设置为0.001秒 ，一毫秒比较合适
  * log_queries_not_using_indexes 是否记录未使用索引的SQL