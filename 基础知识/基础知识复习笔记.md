方法引用：lambda表达式中使用已写好的方法的简化方式
comparator:实现了多种静态比较方法的接口
内部类：非静态内部类中不含数据域，静态内部类中可包含数据域
代理：？
日志：？
泛型约束与局限性：？

设计个人算法时尽量使用接口

You are obviously encountering the first-time initialization overhead of lambda expressions. As already mentioned in the comments, the classes for lambda expressions are generated at runtime rather than being loaded from your class path.

However, being generated isn’t the cause for the slowdown. After all, generating a class having a simple structure can be even faster than loading the same bytes from an external source. And the inner class has to be loaded too. But when the application hasn’t used lambda expressions before, even the framework for generating the lambda classes has to be loaded (Oracle’s current implementation uses ASM under the hood). This is the actual cause of the slowdown, loading and initialization of a dozen internally used classes, not the lambda expression itself.

简单来说就是lambda表达式所对应的类是在运行时生成的，而用于初始化lambda表达式的组件也是在运行时被载入进来的，而后者就是造成性能差距的罪魁祸首

debug小记
	LinkedList 中pop()与push()都是对首元素
个人算法小结：
	学会分析具体代码细节，leetcode131，中对单字符判断回文数的优化
操作系统：
	外中断、异常、陷入（系统调用）
		区别：
	内存管理分配：
		分段：逻辑地址空间分散映射到多个物理地址空间
		分段寻址 操作系统设置段表对逻辑地址与物理地址进行映射

​	分页：（区别：分段段大小可变，页大小不变）
​		页表 页帧 页映射到帧，页是连续的虚拟内存，帧是非连续的物理内存，不是所有的页都有对应的帧
​		有助于减少碎片，提高内存利用率
​		分页机制： 页表占用空间，2次访问内存（页表项、数据
​		TLB（Translation Look-aside Buffer）缓存近期访问的页帧转换表项，解决多次访问内存
​		多级页表，解决页表占用空间
​		基于哈希查找 反向页表（？）

虚拟内存：
	旧方法：覆盖技术、交换技术
	虚拟内存管理技术：
		集覆盖、交换技术的优势
		程序的局部性原理：时间、空间局部性 
		for(j;1024)					for(i;1024)
			for(i)					for(j)
				a[i][j]=0;				a[i][j]=0;
		两种对比，前者1024*1024次缺页中断，后者只有1024
		三种基本特征：
			大的用户空间、部分交换、不连续性
		虚拟页式内存管理
			页表表项 驻留位 保护位 修改位 访问位
		后备储存
		虚拟内存性能 effective memory access time (EAT)
	虚拟内存页面置换算法：
		局部页面置换算法
			最优页面置换算法（OPT）：作为性能评价依据
			先进先出（FIFO）算法： 缺页中断多性能较差，belady现象（给物理页帧越多反而中断多）
			最近最久未使用算法（LRU）：执行开销大
			时钟页面置换算法：环形链表，页面访问位，最老的淘汰，接近LRU算法，单页仅使用一个bit，节省了执行开销
			Enhanced时钟算法：增加脏位
			最不常用算法（LFU）：
		全局页面置换算法
			工作集与常驻集
			缺页率页面置换算法 可变分配策略（PFF） 常驻集大小可变
进程管理：
	进程与程序：程序是进程的基础
	进程的特点：动态性、并发性、独立性（通过页表分配）、制约性（访问共享资源）
	进程控制 进程控制块PCB 进程创建（生成PCB） 进程终止（回收PCB） 
	PCB：进程标识信息
		 处理机状态信息保存区 用户可见寄存器、栈指针等
		 进程控制信息
	PCB组织方式 一般为链表
进程的状态：
	进程的生命期管理：
		进程创建：系统初始化、用户请求创建、已启动进程系统调用
		进程运行：内核选择就绪态进程
		进程等待：等待系统服务、启动某种操作、数据未到达
			进程只能由自身唤醒
		进程唤醒：资源可满足、等待的时间到达、该进程PCB进入就绪队列
			进程只能被其他进程或操作系统唤醒
		进程结束：正常退出、错误退出、致命错误（操作系统）、其他进程结束（强制）
	进程状态变化：
		（创建态）就绪态 运行态	阻塞态（结束态）
		进程挂起：进程挂起时没有占用内存空间，而是映射在磁盘上
			阻塞挂起状态 在外存等待
			就绪挂起状态 在外存等待，但进入内存即可运行
		状态队列
	线程：
		线程时进程当中的一条执行流程
		进程管理资源，进程的执行依赖线程
		TCB
		线程优点：进程中可多线程、并发执行、共享资源
		缺点：一个线程崩溃，会导致所属进程的所有进程崩溃
	线程与进程：
		进程是资源分配单位，线程是CPU调度单位i
		进程由完成的资源、线程只独享必要资源（寄存器和栈）、线程同样由三种状态、
		能够减少并发执行的时间和空间开销：创建与终止以及切换比进程快、不需要通过内核通信快
	线程的实现：
		用户级线程
			os看不到用户级，由线程库管理，不需要状态切换速度快、线程调度由所属进程自定义
			单线程因系统调用阻塞则进程阻塞，单线程占用CPU
		内核级线程
			创建终止切换都由内核完成，开销大、单进程阻塞不会影响其他内核线程、
			多线程进程获得更多CPU时间
		轻量级线程
	上下文切换 就绪队列 等待IO队列 僵尸队列
		切换当前任务，完成线程或进程间切换
		保存当前进度在PCB/TCB的上下文
		读取下一个
	进程控制
		fork() 当前多使用Copy on Write（COM）技术 对应创建新进程
		wait() 父进程wait讲子进程结束
		exit() 从运行态转入僵尸态
调度：
	上下文切换 CPU调度
	调度准则
	非抢占式 抢占式 用户级可以抢占到内核级也可以抢占
	CPU使用率 吞吐量 周转时间 等待时间 响应时间 
	调度算法：
	FCFS 先到先服务：实现简单 不公平等待时间差
	短任务优先
		SRT最短剩余时间（可抢占）
		SPN（非抢占）
		不公平，平均等待时间最小，可能导致饥饿、需要预知程序运行时间
	HRRN 最高响应比优先
		SPN基础上改进、不可抢占、关注进程等待时间、防止无限期延迟 
		R=(waiting +service)/service 选择R值最高的进程
	Round Robin轮循调度算法
		公平，等待时间较差
	MLFQ多级反馈队列调度算法
		类似SPN
	Fair-Share Scheduling公平共享调度（当前的Linux）
		公平优先
	实时调度
		强实时系统
			在保证的时间内完成重要的任务，必须完成
		弱实时系统
			要求重要的进程的优先级更高，尽量完成
		硬时限、软时限
		RM 速率单调调度 
		EDF 最早期限调度
	多处理器调度
		优先级反转
			低优先级任务挤占了高优先级子任务，导致影响高优先级任务的效率
			解决：高优先级子任务继承优先级，保证任务执行
		优先级天花板
			资源优先级和所有可以锁定该资源的任务中优先级最高的那个任务优先级相同
			除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务尝试执行临界区的时候会被阻塞
			持有最高优先级上限信号量锁的任务，会继承被该锁锁阻塞的任务的优先级
进程同步：
	一些概念：
		原子操作：一次不存在任何中断或者失败的执行
		临界区：临界区是指进程中一段访问共享资源的区域且只能为一个进程所独占
		互斥：一个进程处于临界区并访问共享资源是，没有其他进程会处于临界区并访问任何相同的共享资源
		死锁：两个或以上的进程，相互等待完成任务，以至于都无法进行下去
		饥饿：一个可执行的进程，被调度器持续忽略，以至于可执行却无法执行
	通过临界区与互斥保护共享数据域，避免死锁
		互斥、申请后保证能够临界区域、有限等待、尽量避免忙等待（第四点可选）
	临界区实现方法
		1.进入临界区屏蔽硬件中断，避免上下文切换
			禁用中断可能无法停止线程
			无法限制中断响应的时间
			不适用多CPU
		2.基于软件的peterson算法
			通过一个bool数组和一个bool变量实现
			Dekker算法、Bakery算法
			需要两个进程间的共享数据项、需要忙等待浪费CPU时间、没有硬件保证的情况下无法使用（需要原子的LOAD和SAVE
		3.更加高级的抽象 硬件提供了一些原子操作 test-and-set和交换
			基于原子操作的方法优点：适用单处理器以及多处理器中任意数量进程、简单、支持多临界区
			缺点：忙等待消耗CPU时间、可能导致部分进程饥饿、
			死锁-低优先级进程占用临界区而高优先级占处理器等待临界区（同优先级反转问题解决）
	信号量：信号量是一个整数、是一个被保护的变量
			P()能够阻塞、V()不会阻塞
			信号量可以是 0或1，或者是计数信号量
			可以用在互斥与条件同步的情况
		要求：互斥、缓冲区为空消费者等生产者、缓存满生产者等消费者
			  则用一个二值信号量和两个一般信号量
	管程：实现互斥和条件同步的分离关注
		包含了一个锁、还包含0或多个条件变量 收集共享数据、定义方法来访问共享数据
		锁->获取操作、释放操作  条件变量->允许等待状态进入临界区、wait()（释放锁然后睡眠、signal()
		实现：需要维持每个条件队列、线程等待的条件等待signal()
	经典同步问题：
		读者写者问题：
			多个读者写者，读者只读，写者读写，可以同时读不可同时写，共享数据只能有单线程操作
			信号量实现：两个二值信号量+一个Rcount
			管程实现：AR、AW、WR、WW+一个锁 StartRead() DoneRead() StartWrite() DoneWrite()
		哲学家就餐问题：
			原则：不能浪费CPU时间、进程间相互通信
			take_fork() ->要么拿起叉子要么被阻塞
			put_fork() ->把叉子放回，唤醒左右
			管程实现：？
死锁：
	死锁问题：		
	模型：
		资源分配图 环形等待条件可能导致死锁
	死锁特征：
		1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。
		如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
		2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程
		占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
		3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
		4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，
		Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
	死锁处理办法：
		预防
			大多os忽略死锁
			限制申请方式：
				占用并等待：要求要么不占用资源要么占用全部所需资源（资源利用率低，可能饥饿
				无抢占
				循环等待，对资源类型排序，按顺序申请资源
		避免
			需要系统具有一些额外的先验信息提供，了解所需资源的最大数目需求、或动态检查
				动态检查：对进程序列进行特定算法检查
			银行家算法：
				前提：多个实例、每个进程都必须最大限度利用资源、一个进程请求资源必须等待、
				一个进程获得所有的资源旧必须在一段有限的时间释放他们
				计算进程数量及各自需要的资源量，获得总需求量、剩余空闲量、已分配量、未来需求量
		检测
			允许系统进入死锁
			死锁检测算法然后恢复
				算法同样应用了资源分配图得到的资源分配序列，类似银行家算法
				此种算法基本应用于调试而非实际系统
		恢复
	IPC进程间通信
		进程通信的机制及同步
		不使用共享变量的进程通信
		IPC操作 send receive 
		进程间两种通信：直接通信、间接通信
		消息传递：阻塞（同步）、非阻塞（异步）
		信号：
			软件中断通知事件处理
			修改应用程序的堆栈
		管道：
			进行数据交换 shell 创建管道
		消息队列：
		共享内存：
			每个进程都有私有地址空间，且明确设置了共享内存段
			优点 快速方便地共享数据
			不足 必须同步数据访问
			最快的方法、一个进程写另一个进程立即可见、没有系统调用干预、没有数据复制、
			不提供同步（程序自己实现同步
文件系统：
	文件系统功能
		分配文件磁盘空间
			管理文件块
			管理空闲空间
			分配算法
		管理文件集合
			定位文件及内容
			命名
			文件系统类型
		提供便利及特征
	文件
		文件属性
		文件头
	文件描述符
		文件指针 指向最近一次读写位置
		文件打开计数
		文件磁盘位置 缓存数据访问信息
		访问权限 
	目录
	文件别名
	种类：
		磁盘文件系统 FAT NTFS ext2/3
		数据库文件系统 WinFS
		日志文件系统 journaling file system
		网络/分布式文件系统 NFS SMB AFS GFS	
			文件可以通过网络被共享
			分布式文件系统的问题
				辨别复杂
				NFS不安全
				一致性问题
				错误处理模式
		特殊/虚拟文件系统
			目的 对所有不同文件系统的抽象
			功能 
				提供相同的文件和文件系统接口
				管理所有文件和文件系统关联的数据结构
				高效查询例程，遍历文件系统
				与特定文件系统模块的交互
		文件系统数据结构
			卷控制块（Unix： superblock） 挂载时进入内存
			文件控制块（Unix：vnode or inode） 文件被访问时进入内存
			目录节点（Linux：dentry） 遍历文件目录时进入内存
		数据块缓存
			按需读入内存
			数据块使用后被缓存
			两种缓存方式：
				普通缓冲区缓存
				页缓存
					虚拟内存中文件数据块被映射成页
					读写被转换成对内存的访问
					？？？可能导致缺页设置为脏页
		文件分配
			分配方式 
				连续分配
					cd-rom 读取表现好、高效的顺序和随机访问 碎片、文件增长
					适合只读情况
				链式分配
					创建、增加、删除容易，没有碎片 非随机访问、可靠性低
				索引分配
					创建、增加、删除容易、没碎片、支持直接访问 文件小时索引开销大、
					大文件可能索引块不够
						链式索引块
						多级索引块 分层 早期Unix
							优化文件大小限制
							文件扩展容易
							小文件开销小
			指标：
				高效：储存利用、访问速度
		空闲空间管理
		多磁盘管理
			RAID 冗余磁盘阵列
			各种磁盘管理技术
			RAID levels 不同RAID分类 RAID-0,RAID-1等
			RAID-0：并行访问数据，提高吞吐率
			RAID-1：可靠性提升、读取性能线性增加 （类似镜像
			RAID-4：奇偶校验磁盘，并行多个+故障恢复盘
			RAID-5：将故障恢复分布到各个独立盘
		磁盘调度
			

设计模式：
	六大原则：	

			可维护性Maintainability
				修改功能，需要改动的地方越少，可维护性越好
			可复用性Reusability
				代码可以被重用
				写出自己总结的类库
			可扩展性Extensibility/Scalability
				添加功能无需修改原来代码
			灵活性Flexibility/adaptability
				代码接口可以灵活调用
		单一职责原则Single Responsibility Principle
			一个类负责单一的职责
			高内聚，低耦合
		里氏替换原则Liscov Substitution Principle
			所有使用父类的地方，必须能够透明的使用子类对象
		依赖倒置原则Dependency Inversion Principle
			依赖抽象，而不是依赖具体
			面向抽象编程（面向接口编程
		接口隔离原则Interface Segregation Principle
			每一个接口应承担独立的功能
			避免子类实现实现不需要实现的方法
			面对客户提供接口的时候，只需要暴露最小的接口
		迪米特法则Law of Demeter
			尽量不要和陌生人说话
			一个对象的非陌生人
			this、以参数形式传入到当前对象方法中的对象、当前对象的成员对象、如果当前对象的成员对象是一个
			集合，那么集合中的元素也包含、当前对象所创建的对象
			和其他类的耦合度变低
	Singleton 只需要一个实例存在，构造函数私有化
		实现方式1：（饿汉式）
			类加载到内存中就实例化一个单例，JVM保证线程安全，缺点时无论用到与否都会实例化
			private static final 类 INSTANCE = new 类();
		实现方式2：（懒汉式）
			private static volatile 类 INSTANCE; volatile防止指令重排时出现问题
			在getInstance()中判断是否为空来实例化，多线程访问可能出现多个实例
			优化：
				getInstance()加synchronized，缺点：降低效率
			继续优化
				两层if判断为空，内层if外对代码块加锁
		实现方式3：静态内部类
			·private static class 内部类{
				private final static 类 INSTANCE=new 类();
			}	
			public static getInstance(){
					return 内部类.INSTANCE;
			}
		实现方式4：枚举类（枚举类型天生线程安全：？待理解）解决线程同步、防止反序列化
			INSTANCE;
		序列化：java反射机制实例化，可能导致多个实例
	Strategy策略模式
		comparable 
			接口有方法实现了（从1.8之后，为了lambda表达式
			实现comparable接口的类实现compareto()方法
			对象类型为Comparable
		comparator
			排序策略
			可结合lambda表达式
	factory工厂模式
		简单工厂模式
			createCar(){
				return new Car();
			}
			可扩展性不好
			或直接carFactory直接create()方法
		抽象工厂模式
		bean工厂
		
		Facade外观
			public class SubSystem{
				...
			}
			public class Facade{
				private SubSystem subsystem=new SubSystem;
				方法(){
					subSystem.方法();
				}
			}
			最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。
		Mediator调停者（应用：消息中间件）解耦合
			同一个设计可以同时使用以上两种，对外为facade对内mediator
			public abstract class Colleague {
				public abstract void onEvent(Mediator mediator);
			}
			其他对象继承 Colleague
			public abstract class Mediator {
				public abstract void doEvent(String eventType);
			}
			public class ConcreteMediator extends Mediator {
				private 类名 类;
				@Override mediator
			}
		Decorator装饰器
			为对象动态添加功能，其中decorator和concretecomponent都继承自component
				（待理解）
			设计原则：
				类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。
				饮料可以动态添加新的配料，而不需要去修改饮料的代码。
		Chain of responsibility责任链
			class Msg{} 
			class Request{}
			class Response{}
			interface Filter{				
				void doFilter(Request req,Response rep){
				}
			}
			class xxxFilter implements Filter{
				void add(Msg m){}
				boolean doFilter(Request req,Response rep){}
			}
			...
			class FilterChain implements Filter{
				List<Filter> filters=new ArrayList<>();
				两种方式
				链式执行
				public FilterChain add(Filter f){
					f.add();
					return this;
				}
				public boolean doFilter(Request req,Response rep){
					for(Filter f:filters){
						if(!f.doFilter(Request req,Response rep))	
							return false;
					}
				}
				通过下标index实现对单个的调用
				if(index==filters.size()) return false;
				Filter filter=filters.get(index);
				index++;
				return f.doFilter(request,response,chain);
			}
			同时index实现了request与response执行顺序反向的作用
			具体实现见com.company.TestResponseChain
		Observer观察者
			主题（Subject）
				具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。
			观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。
			public interface Subject {
				void registerObserver(Observer o);
				void removeObserver(Observer o);
				void notifyObserver();
			}
			public class WeatherData implements Subject {				
				public WeatherData() {
					observers = new ArrayList<>();
				}
				public void setMeasurements(float temperature, float humidity, float pressure) {					
				}
				@Override				
			}
			public interface Observer {(ActionListener接口，actionPerformed(ActionEvent e))
				void update(float temp, float humidity, float pressure);
			}
			public class StatisticsDisplay implements Observer {
				@Override
			}
			public class CurrentConditionsDisplay implements Observer {
				@Override
			}
		Composite组合
			处理树状结构
			abstract class Node{
				abstract public void p();
			}
			class LeafNode extends Node{
				String content;
				public void p();
			}
			class BranchNode extends Node{
				List<Node> list=new ArrayList<>();
				String name;
				public void p();
				public void add(Node n){
					list.add(n);
				}
			}
		flyweight享元
			文本编辑软件，字符为享元，提前new好，用时直接调用
			java中的String类即是享元 利用缓存来加速大量小对象的访问时间
		Proxy代理
			远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，
				并向不同地址空间中的对象发送已经编码的请求。
			虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，
				以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小
				信息，然后生成一张临时图片代替原始图片。
			保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求
				所必须的访问权限。
			智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：
				记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，
				检查是否已经锁定了它，以确保其它对象不能改变它。
			
			静态代理
			interface movable{
				void move(){}
			}
			class tank extends movable{
				movable xxx=new tank;
				void move(){}
			}
			动态代理
				Movable m=(Movable)Proxy.newProxyInstance(  
					Tank.class.getClassLoader(),
					new Class[]{Movable.class},
					new InvocationHandler()){
						public Object invoke(Object proxy,Method method,Object[] args){
						}
					});
			Instrument代替asm
			CGLIB
				main{
					Enhancer enhancer =new ENhancer();
					enhancer.setSuperclass(Tank.class);
					enhancer.setCallback(new TimeMethodInterceptor());
					Tank tank=(Tank)enhancer.create();
					tank.move();
				}
				class TimeMethodInterceptor implements MehtodInterceptor{
					public Object intercept(Object o,Method method,Object[] objects,MethodProxy methodProxy){
						sout(before);
						Object result=null;
						result=methodProxy.invokeSuper(o,objects);
						sout(after);
						return result;
					}
				}
		Iterator迭代器
			interface Iterator{
				boolean hasNext(){}
				Object next(){}
			}
			class ArrayList implements Collection{
				public Iterator iterator(){
					return new ArrayListIterator();
				}
				private class ArrayListIterator implements Iterator{
					
				}
			}
		Visitor访问者：在结构不变的情况下动态改变对于内部元素的动作
			自身结构固定的情况下才建议使用，多用于jvm开发
		Bulider
			多参数时
			class Person{
				int id;
				String name;
				int age;
				int weight;
				int score;
				private Person(){}
				public static class PersonBuilder{
					Person p=new Person();
					public PersonBuilder basicInfo(int id,String name,int age){
						p.id=id;
						p.name=name;
						p.age=age;
						return this;
					}
					public PersonBuilder weight(int weight){
						p.weight=weight;
					}
					public PersonBuilder score(int score){
						p.score=score;
					}
				}
			}
		Adapter适配器 java.util.Arrays#asList()  java.util.Collections#list()
			JDBC-ODBC Bridge
			常见的Adapter类并不是适配器
		Bridge桥接
			分离抽象和具体，用聚合的方式连接抽象和具体
			抽象类中正常实现自己的分类，但在其中聚合一个实际类的实例
			class WarmGift extends Gift{
			}
			class WildGift extends Gift{
			}
			abstract class Gift{
				GiftImpl gift=new GiftImpl();
			}
			class Flower extends GiftImpl{
			}
			class Book extends GiftImpl{
			}
			main(){
				Gift g=new WarmGift(new Flower());
			}
		Command （别名Action、Transaction
			将命令封装成对象中，具有以下作用：
				使用命令来参数化其它对象
				将命令放入队列中进行排队
				将命令的操作记录到日志中
				支持可撤销的操作
			abstract class Command{
				public abstract void doit();
				public abstract void undo();
			}
			多次undo命令使用责任链+Command
			宏命令使用Composite+Command
		Prototype
			Object.clone()深拷贝与浅拷贝
			自带，需要实现标记型接口Cloneable，需要自己重写clone()
		Memento备忘 记录快照（瞬时状态）和存盘
		TemplateMethod 即回调函数
			abstract class F{
				void m(){
					op1();
					op2();
				}
				
				abstract void op1();
				abstract void op2();
			}
			
			class C1 extends F{
				void op1(){}
				void op2(){}
			}
		State
			abstract class State{
				void xxx(){}
				void xxx(){}
				void xxx(){}
				void xxx(){}
			}
		Interpreter解释器

数据库：
	数据的概念：数据是数据库中储存的基本对象，数据的含义为数据的语义
	数据库DB：长期储存、有组织、可共享、大量数据：长期储存、有组织、可共享、大量数据
		特征：按一定的数据模型组织、描述和储存；可共享；冗余度较小；数据独立性较高；易扩展
	数据库管理系统DBMS
		DBMS的用途：
			数据定义，数据组织、储存和管理，数据操纵
			主要功能：
				运行管理、建立和维护
	数据库系统
		组成：数据库、数据库管理系统、应用系统、数据库管理员
	SQL Structure Query Language结构化查询语言 专门与数据库通信
	数据库的特点：
		数据放到表中，表再放在库中
		一个数据库中可以有多个表，每个表都有一个名字标识，具有唯一性
		表具有一些特性，定义了数据再表中如何储存，类似java中“类”
		表由列组成，也称字段，所有表都是由一个或多个列组成的，每一列类似java中的”属性“
		表中的数据是按行储存的，每一行类似java中的“对象”
		Mysql启动： mysql -h 主机名 -P端口号 -u 用户名 -p 密码
		show databases;
		use 库名;
		show tables;
		show tables from 库名;
		create table 表名(
			列名 列类型,
			列名 列类型,
			...
		);
		查看表结构： desc 表名
		mysql不区分大小写，但关键字大写，表明列名小写
	DQL语言的学习
		做查询时前面添加命令 USE 库名;
		基础查询
			select 查询列表 from 表名
			查询列表可以是：表中的字段、常量值、表达式、函数
			查询的结果是一个虚拟的表格
			exp：查询表中的单个字段
					SELECT last_name FROM employees;
				 查询表中的多个字段
					SELECT last_name,salary,email FROM employees;
				 查询表中的所有字段
					SELECT (自己鼠标点选)/* FROM employees;(星号不可以自定义顺序
				 查询常量值
					SELECT 100; SELECT 'john';
				 查询表达式
					SELECT 100%98；
				 查询函数
					SELECT version();
				 可以起别名
					 SELECT 100%98 AS 结果;
					 SELECT last_name AS 姓,first_name AS 名 FROM employees;
					或 SELECT last_name 姓,first_name 名 FROM employees;
				 别名可加双引号避免歧义报错
				 去重
					SELECT DISTINCT department_id FROM employees;
				 加号
					mysql中对字符型进行转换，转换成功则继续运算，否则字符型转化为0，如果有一方为null，则
					结果输出null
				 SELECT CONCAT('a','b','c') AS 结果; 则输出 abc
				 IFNULL(字段,数值)
		条件查询
			SELECT
				查询列表
			FROM
				表名
			WHERE
				筛选条件
			支持条件运算符（包括模糊查询）、逻辑表达式AND NOT OR
				模糊查询：like、between and、in、is null
			模糊查询
				like
					通配符：%->0-n个任意字符、_一个任意字符
					用\转义，或 last_name LIKE '_$_%' ESCAPE '$';($可换成任意字符充当转义)
				between and
					包含为闭区间
				in
					job_id('','','');
				is null/is not null ->由于= <> 不可判断null值
				<=>安全等于（可以判断null
		排序查询
			语法：
				SELECT 查询列表 FROM 表 where 筛选条件 ORDER BY 排序列表(ASC|DESC);
			特点：
				默认升序；order by 支持单个多个字段、表达式、函数、别名；一般放在查询语句最后
				（只有Limit 子句在其后
			SELECT * FROM employees ORDER BY salary DESC;
			SELECT * FROM employees ORDER BY salary ASC;(ACS为默认方式
			按年薪高低显示员工的信息和 年薪按表达式顺序
			SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees 
			ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;
			按年薪高低显示员工的信息和 年薪按别名顺序
			SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees 
			ORDER BY 年薪 DESC;
			按函数排序
			SELECT LENGTH(last_name) 字节长度，last_name,salary FROM employees 
			ORDER BY LENGTH(last_name) DESC;
			按多个字段排序
			SELECT * FROM employees ORDER BY salary ASC,employees_id DESC;
		常见函数：类似方法
			单行函数：
				concat、length、ifnull等
				字符函数
					SELECT LENGTH 注意这里是字节长度
					CONCAT( , , )
					UPPER,LOWER
					SUBSTR、SUBSTRING sql中索引从1开始，substr的第三个参数为长度类似C++substr
					INSTR 返回子串中出现的第一次起始位置，否则返回0
					TRIM （'a' FROM 'aaaaneawwwaaaa'）则仅去掉前后两端的a
					LPAD ('test',10,'*') output 则左边用星号填充至10个字符（如果输出长度小于原字符则截断
					RPAD同理
					REPLACE('test','e','s')
				数学函数
					ROUND四舍五入 SELECT ROUND(1.45);
					CEIL向上取整
					FLOOR返回<=该参数的最大整数
					TRUNCATE截断 SELECT TRUNCATE(1.555，1)保留一位小数
					MOD取余
				日期函数
					SELECT NOW();返回当前系统日期+时间
					SELECT CURDATE();返回当前系统日期
					SELECT CURTIME();返回当前时间
					SELECT YEAR(NOW()) 年;
					SELECT MONTHNAME(NOW());
					str_to_date将日期格式的字符串转汉城指定格式的日期
					STR_TO_DATE('9-13-1999','%m-%d=%Y');
					date_format:将日期转换成字符
					SELECT DATE_FORMAT(NOW(),'%y年%m月%d日') AS out_put;
				其他函数
					SELECT VERSION();
					SELECT DATABASE();
					SELECT USER();
					SELECT PASSWORD('');//字符加密
				流程控制函数
					IF类似三目运算符?:
					SELECT IF(10>5,'大'，'小');
					CASE
						类似switch
						CASE department_id
						WHEN 30 THEN salary*1.1
						WHEN 40 THNE salary*1.2
						ELSE salary
						END AS 新工资
						FROM employees;
						类似多重if-else
						CASE
						WHEN salary>20000 THEN 'A'
						WHEN salary>15000 THEN 'B'
						ELSE 'D'
						END AS 工资级别
						FROM employees;
		分组函数
			用于统计又称聚合、统计函数
			SUM、AVG、MAX、MIN、COUNT
			SUM、AVG对数值型处理
			MAX、MIN、COUNT对任何类型可处理
			所有的分组函数都忽略NULL值
			都可以和DISTINCT搭配实现去重
			COUNT详解
				SELECT COUNT(*) FROM employees;统计行数
				SELECT COUNT(1) FROM employees;
				MYISAM引擎COUNT(*)效率高INNODB两者差不多，比COUNT(字段)效率高
			和分组函数一同查询的字段要求是group by后的字段
			DATEDIFF计算两参数差值
		分组查询
			语法：
				SELECT 分组函数，列
				FROM 表
				WHERE 删选条件
				GROUP BY 分组的列表
				ORDER BY 子句
			案例：
				SELECT AVG(salary)，department_id
				FROM employees
				WHERE email LIKE '%a%'
				GROUP BY department_id;
				
				SELECT COUNT(*),department_id
				FROM employees
				GROUP BY department_id
				HAVING COUNT(*)>2;
				
				SELECT MAX(salary),job_id
				FROM employees
				WHERE commission_pct IS NOT NULL
				GROUP BY job_id
				HAVING MAX(salary)>12000
				
				SELECT MIN(salary),manager_id
				FROM employees
				WHERE department_id>102
				GROUP BY manager_id
				HAVING MIN(salary)>5000;
			特点：
				筛选条件 两者筛选数据源不同
					分组前筛选
						筛选的是原始表
					分组后筛选
						筛选的是分组后的结果集
				能分组前筛选的尽量分组前筛选（性能考虑
				GROUP BY支持多分组
				支持按表达式或函数分组
					按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些
					SELECT COUNT(*),LENGTH(last_name) len_name
					FROM employees
					GROUP BY LENGTH(last_name)
					HAVING COUNT(*)>5;
			添加排序
				SELECT AVG(salary),department_id,job_id
				FROM employees
				WHERE department_id IS NOT NULL
				GROUP BY job_id,department_id
				HAVING AVG(salary)>10000
				ORDER BY AVG(salary) DESC;				
		连接查询 又称多表查询
			分类
				内连接：sql99中类型为inner
				sql99
						SELECT 查询列表
						FROM 表1 别名 连接类型
						JOIN 表2 别名
						ON 连接条件
					等值连接
						SELECT NAME,boyName FROM boys,beauty
						WHERE beauty.boyfriend_id=boys.id;
						查询员工名、工种号、工种名
						可以为表起别名
						SELECT last_name,employees.job_id,job_title
						FROM employees,jobs
						WHERE employees.`job_id`=jobs.`job_id`;
						可以加筛选
						SELECT last_name,department_name						
						FROM employees,departments
						WHERE employees.`department_id`=departments.department_id
						AND employees.`commission_pct` IS NOT NULL;
						可以加分组
						查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资
						SELECT department_id,d.`manager_id`,MIN(salary)
						FROM departments d,employees e
						WHERE d.`department_id`=e.`department_id`
						AND commission_pct IS NOT NULL
						GROUP BY department_name,d.`manager_id`;
						可以加排序
							SELECT job_title,COUNT(*)
							FROM employees e,jobs j
							WHERE e.`job_id`=j.`job_id`
							GROUP BY job_title
							ORDER BY COUNT(*) DESC;
						可以进行三表连接
							SELECT last_name,department_name,city
							FROM employees e,departments d,locations l
							WHERE e.`department_id`=d.`department_id`
							AND d.`location_id`=l.`location_id`
							AND city LIKE 's%'
							ORDER BY department_name DESC;
						也可以加分组后筛选
						注意
							多表连接的结果为多表的交集部分
							n表连接至少需要n-1个连接条件
							多表的顺序无要求，一般需起别名
							可搭配其他子句使用
					非等值连接
						查询员工的工资和工资级别
						SELECT salary,grade_level
						FROM employees e,job_grades g
						WHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`
						AND g.`grade_level`;
					自连接
						SELECT e.employee_id,e.last_name,m.employee_id,m.last_name
						FROM employees e,employees m
						WHERE e.`manager_id`=m.`employee_id`;
					小结：
						SELECT 查询列表
						FROM 表1 别名1，表2 别名2（等值连接、非等值连接
						FROM 表 别名1，表 别名2（自连接
						WHERE （非）等值的连接条件
						AND 筛选条件
						GROUP BY 分组字段
						HAVING 分组后的筛选
						ORDER BY 排序字段					
				外连接：连接类型outer
					用与查询一个表有，另一个表没有的记录					
					左外连接left outer
						SELECT <select_list>
						FROM A
						LEFT OUTER JOIN B
						ON A.key=B.key
						WHERE B.key IS NULL;
						左外连接还返回左表中不符合连接条件单符合查询条件的数据行。
					右外连接right outer
						SELECT <select_list>
						FROM B
						RIGHT OUTER JOIN A
						ON A.key=B.key
						WHERE A.key IS NULL;					
					右外连接还返回右表中不符合连接条件单符合查询条件的数据行。
					全外连接（mysql不支持）
					全外连接还返回左表中不符合连接条件单符合查询条件的数据行，并且还返回右表中不符合连接
					条件单符合查询条件的数据行。全外连接实际是上左外连接和右外连接的数学合集（去掉重复），
					即“全外=左外 UNION 右外”。
				交叉连接cross
					SELECT b.*,bo.*
					FROM beauty b
					CROSS JOIN boys bo;结果为笛卡尔乘积结果
		子查询
			出现在其他语句中的select语句，成为子查询或内查询
				select后
					标量子查询
				FROM后
					表子查询
				WHERE或HAVING后
					标量子查询、列子查询、行子查询
				EXISTS后
					表子查询
			分类：
				标量子查询 结果集只有一行一列
				列子查询 结果集只有一行多列
				行子查询 结果集有一行多列
				表子查询 结果集一般为多行多列
			where和having后面
				标量子查询（单行
					SELECT salary				SELECT last_name,job_id,salary
					FROM employees				FROM employee
					WHERE salary>(				WHERE job_id=(
						SELECT salary				SELECT job_id
						FROM employees				FROM employees
						WHERE last_name				WHERE employee_id=141
					);							) AND salary>(
													SELECT salary
													FROM employees
													WHERE employee_id=143
												);
					非法使用：若标量子查询结果不是一行一列则为非法
					SELECT  MIN(salary),department_id
					FROM employees
					GROUP BY department_id
					HAVING MIN(salary)>(
						SELECT MIN(salary)
						FROM employees
						WHERE department_id=50
					);
				列子查询（多行
					使用多行、使用多行比较操作符
						（不）等于列表中的一个IN/NOT IN
						和子查询返回的某一个值比较ANY|SOME满足其中一个值即可
						和子查询返回的所有值比较 满足全部
							返回location_id是1400或1700的部门中的所有员工姓名
							SELECT last_name
							FROM employees
							WHERE department_id IN(
								SELECT DISTINCT department_id
								FROM departments
								WHERE location_id IN(1400,1700);
							);
							返回其他工种中比job_id为`IT_PROG`工种任一工资低的员工的员工号、姓名、job_id、salary
							SELECT last_name,employee_id,job_id,salary
							FROM employees
							WHERE salary<ANY(
								SELECT DISTINCT salary
								FROM employees
								WHERE job_id='IT_PROG'
							) AND job_id<>'IT_PROG';
				行子查询（多列多行
					查询员工编号最小并且工资最高的员工信息
					SELECT *
					FROM employees
					WHERE (employee_id,salary)=(
						SELECT MIN(employee_id),MAX(salary)
						FROM employees
					);或者用以下形式
					SELECT *
					FROM employees
					WHERE employee_id=(
						SELECT MIN(employee_id)
						FROM employee
					) AND salary=(
						SELECT MAX(salary)
						FROM employees
					);
				特点：
					子查询放在小括号内、子查询一帮放在条件的右侧、标量子查询一般搭配着单行操作符使用
					列子查询，一般搭配着多行操作符使用
			SELECT后面：仅支持标量子查询
				查询每个部门的员工个数
				SELECT d.*,(
					SELECT COUT(*)
					FROM employees e
					WHERE e.department_id=d.`department_id`
				)个数
				FROM departments d;
			FROM后面
				将子查询结果充当一张表要求必须起别名
				查询每个部门平均工资的工资等级
				SELECT ag.dep.*,g.`grade_level`
				FROM (
					SELECT AVG(salary),department_id
					FROM employees
					GROUP BY department_id
				)ag_dep
				INNER JOIN job_grades g
				ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;
			EXISTS后面：相关子查询
				SELECT EXISTS(SELECT employee_id FROM employees  WHERE salary=30000);返回1或0
		分页查询
			当显示的数据，一页显示不全，需要分页提交sql请求
			SELECT 查询列表
			FROM 表
			连接类型 JOIN 表2
			ON 连接条件
			WHERE 筛选条件
			GROUP BY 分组字段
			HAVING 分组后的筛选
			ORDER BY 排序的字段
			LIMIT offset,size;
			特点：
				limit语句放在查询语句的最后
				每页公式为 SELECT 查询列表 FROM 表 LIMIT (page-1)*size,size;
		union联合查询
			将多条查询语句合并成一个结果
			应用场景：
				多个表没有连接关系，但是列数相同的表
			特点：
				多条查询语句列数一致、字段名和类型顺序要一致、自动去重（取消去重则UNION ALL）
		查询时，先确认是否所需数据都在一张表里，决定是否连接表，再进行筛选，注意GROUP BY前后筛选
	DML语言的学习
		插入语句insert
			语法：
				insert into 表名（列名，...）
				values(值，...)
				或
				insert into 表名
				set 列名=值,列名=值;
			插入的类型要与列的类型一致或兼容
			INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)
			VALUES(13,'唐艺昕','女','1990-4-23','18988888888',NULL,2);
			不可为NULL的值可以写NULL或省略
			可以省略列名，但是此时NULL值不能省略写
			两种语法
				前者支持插入多行VALUES(),(),();后者不支持
				前者支持子查询 SELECT ,后者不支持
		修改语句update
			修改单表的记录
				语法：
					update 表名
					set 列=新值,列=新值,...
					where 筛选条件;
			修改多表的记录
				语法：
					update 表1
					inner|left|right join 表2
					set 列=值,列=值
					where 筛选条件;
				例：
					UPDATE boys bo
					INNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`
					SET b.`phone`=`114`
					WHERE bo.`boyName`=`张无忌`;
					UPDATE boys bo
					RIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`
					SET b.`boyfriend_id`=2
					WHERE bo.`id` IS NULL;
		删除语句delete
			单表删除
			delete from 表1,表2
			inner|left|right join 表2
			on 连接条件
			where 筛选条件;			
			多表删除
			truncate table 表名;
			注意：如果删除的表中有自增长列，delete后再插入数据，值从断点开始，ertruncate从1开始
				truncate 没有返回值，delete有返回值;truncate不能回滚，delete可以回滚;
	DDL语言的学习 数据定义语言
		库的管理
			创建
				语法：
				create database IF NOT EXISTS 库名;
			修改（一般不做修改
				可改字符集：ALTER DATABASE books CHARACTER SET gbk;
			删除
				DROP DATABASE IF EXISTS books;
		表的管理
			创建
				CREATE TABLE 表名(
					列名 列的类型(长度)约束,
					列名 列的类型(长度)约束,
					列名 列的类型(长度)约束,
				);
				CREATE TABLE book(
					id INT,#编号
					bName VARCHAR(20),
					authorId INT,
					publishDate DATETIME
				);
			修改
				修改列名
				ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;
				修改列的类型或约束
				ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;
				添加新列
				ALTER TABLE author ADD COLUMN annual DOUBLE;
				删除列
				ALTER TABLE author DROP COLUMN annual;
				修改表名
				ALTER TABLE author RENAME TO book_author;
			删除
				DROP TABLE IF EXISTS book_author;
				通用写法
					DROP DATABASE IF EXISTS 旧库名;
					CREATE DATABASE 新库名;
					DROP TABLE IF EXISTS 旧表名;
					CREATE TABLE 表名();
			表的复制
				仅仅复制表的结构
					CREATE TABLE LIKE author;
				复制表的结构+数据
					CREATE TABLE copy2
					SELECT * FROM author;
				仅复制某些字段
					CREATE TABLE copy4
					SELECT id，au_name
					FROM author
					WHERE 0;
	常见的数据类型
		整形
			tinyint、smallint、mediumint、int/integer、bigint
			用UNSIGNED标识有无符号，超范围则为临界值，如果不设置长度，会有默认的长度
			长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配ZEROFILL
		小数	
			浮点数
				float(M,D) double(M,D)
			定点数
				DEC(M,D) DECIMAL(M,D)
			特点：M为总位数，D为小数位数，默认float、double符合范围即可，decimal默认10,0
			选择类型越简单越好，能保存数值的类型越小越好
		字符型
			较短文本char、varchar
				char固定长度字符M默认为1，varchar可变长度字符M无默认必须指定，char性能高
			较长文本test、blob
		枚举
		集合
			CREATE TABLE tab_set(
				s1 SET/ENUM('a','b','c','d')
			);
			集合插入多个，枚举插入一个
		日期型
			date、datetime、timestamp、time、year
			datetime从1000-1-1到9999-12-31
			timestamp则和实际时区有关，反应实际时间，且受mysql版本和sqlmode的影响，范围1970某时到2038某时
	常见约束：限制表中的数据，为了保证表中的数据的准确性和可靠性
		六大约束
			NOT NULL
			DEFAULT：保证该字段有默认值
			PRIMARY KEY：主键，用于保证该字段的值的唯一性，并且非空
			UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空
			CHECK:（mysql中不支持）
			FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自主表的关联列的值
				在从表添加外键约束，用于引用主表中的某列的值，比如各种编号
		添加约束时机：
		创建表时	
		分类
			列级约束
				六种语法都支持，但外键无效果
				直接在字段名和类型后面追加约束类型
			表级约束
				六种中除了非空和默认都支持
				[constraint 约束名] 约束类型(字段名) [FOREIGN KEY() REFERENCE 表名(字段名)];
				CREATE TABLE IF NOT EXISTS stuinfo(
					id INT PRIMARY KEY,
					stuname VARCHAR(20) NOT NULL,
					sex INT DEFAULT 18,
					seat INT UNIQUE,
					majorid INT,
					CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCE major(id)
				);
			主键和UNIQUE：
				主键只能在一个表里有一个，但可以有联合主键（不推荐），UNIQUE可以有多个，也可以组合
			外键
				要求在从表设置外键关系、从外的外键列的类型和朱标的关联列的类型要求一致或兼容，名称无要求
				主表的关联列必须是一个key（一般时主键或UNIQUE）
				删除数据时先删从表才能再删除主表
		修改表时
			列级约束：ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) 约束;
			表级约束：ALTER TABLE stuinfo ADD UNIQUE(seat);
			ALTER TABLE stuinfo ADD FOREIGN KEY(majorid) REFERENCE major(id);
		修改表时删除约束
			NOT NULL 改为NULL 默认改为不写 删除主键ALTER TABLE stuinfo DROP PRIMARY KEY;
			删除UNIQUE ALTER TABLE 表名 DROP INDEX 字段名;
			删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 字段名;
	标识列：自增长列
		类型后+AUTO_INCREMENT
		要求仅给主键、外键或UNIQUE类型添加
		一个表至多一个标识列
		修改为非标识列时直接后面不写
	TCL语言的学习 Transaction Control Language
		事务和事务处理
			事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行
			事务的ACID属性
				原子性：事务是一个不可分割的工作单位，操作要么都发生要么都不发生
				一致性：事务必须是一个数据库从一个一致性状态变换到另一个一致性状态
				隔离性：一个事务的执行不能被其他事务干扰，事务内部操作对其他并发事务隔离，不可相互干扰
				持久性：一个事务一旦被提交，他对数据库中的改变就是永久性的，后续操作不会有任何影响
			隐式事务没有明显的开始和结束如：insert、update、delete
			一般的显式事务都是insert、update、delete
			显示事务必须先设置自动提交功能为禁用set autocommit=0;
				开启事务：
					set autocommit=0;start transaction;
				编写sql
				结束事务
					结束时才决定提交事务或回滚事务
			在事务进行中，delete可以回滚，truncate支持回滚
			并发问题
				脏读：2读取了1没提交的数据（例如1回滚
				不可重复读：2读了数据后1更新
				幻读：2读取了后1插入数据
				read uncommitted、read committed、repeatable read、
				设置当前连接的隔离级别
				set transaction isolation level read committed;
				设置数据库系统的全局的隔离级别
				set global transaction isolation level read committed;
					savepoint 节点名;
					rollback to 节点名;
			视图：虚拟表，和普通表一样使用 重用语句，简化操作，保护数据，提高安全性			
			DROP VIEW 视图名、视图名;
			视图的更新
				CREATE OR REPLACE VIEW my_vl 
				AS
				SELECT .....
				或 ALTER VIEW +后续一样
				视图的增删会影响原表
				包含以下关键字的sql语句：分组函数、distinct、GROUP BY、HAVING 、UNION或者UNION ALL
				SELECT、JOIN、FROM、WHERE子句的子查询引用了FROM子句中的视图不允许更新
	变量
		系统变量
			查看所有的系统|会话变量
			SHOW GLOBAL|SESSION VARIABLES [LIKE '%char%'];
			查看某个指定的系统|会话变量
			SELECT @@GLOBAL|SESSION.系统变量名
			为某个系统变量赋值 若显式声明则默认为 SESSION			
			SET GLOBAL|SESSION 名=值;
			SET @@GLOBAL|SESSION.系统变量名=值;
			全局变量：作用域：每次启动全局变量赋初值，对全局会话有效，重启无效				
			会话变量：针对于单独的会话（连接）有效			
		自定义变量
			用户变量：针对与当前会话或连接有效
			声明并初始化（弱类型
				SET @用户变量名=值;
				SET @用户变量名:=值;
				SELECT @用户变量名:=值;
			赋值同声明
			或 SELECT 字段 INTO @变量名 FROM 表;			
			局部变量：仅仅定义在它的begin end中有有效
			声明：DECLARE 变量名 类型 [DEFAULT 值];
			赋值：同
			注意用户变量名必须加@不用限定类型，局部变量可以不加@必须限定类型
	存储过程和函数 
		存储过程是一组预先编译好的sql语句的集合，提高重用性、简化操作，减少编译和连接次数，提高效率
			创建
				语法
					CREATE PROCEDURE 储存过程名(参数列表)
					BEGIN
						储存过程体
					END
				参数模式：IN作为输入 OUT作为返回值 INOUT作为输入且返回值
				如果存储过程体中仅有一句话则可省略BEGIN END
				储存过程中每句sql结尾必须加分号，结尾可以用DELIMITER重新设置：DELIMITER 结束标记
			调用
				CALL 储存过程名(实参列表);
				例
					DELIMITER $
					CREATE PROCEDURE myp1()
					BEGIN
						INSERT INTO admin(user,`password`)
						VALUES(),(),(),()
					END $
					CALL myp1()$
					CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))
					BEGIN
						SELECT bo.*
						FROM boys bo
						RIGHT JOIN beauty b ON bo.id= b.boyfriend_id
						WHERE b.name=beautyName;
					END $
					创建储存过程实现传入用户名和密码，插入到admin表中
					CREATE PROCEDURE test_pro1(IN username VARCHAR(20)),IN loginPwd VARCHAR(20)
					BEGIN
						INSERT INTO admin(admin.username,PASSWORD)
						VALUES(username,loginpwd);
					END $
					传入女神名称返回 女神and男神格式的字符串
					CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))
					BEGIN
						SELECT CONCAT(beautyName,' and ',IFNULL(boyName,'null')) INTO str
						FROM boys bo							
						RIGHT JOIN beauty b ON b.boyfriend_id=bo.id
						WHERE b.name=beautyName;
					END $
					CALL test_pro5('小昭',@str)$
					SELECT @str $
			删除
				DROP PROCEDURE 储存过程名
			查看
				SHOW CREATE PROCEDURE 存储过程名;
		函数 有且只能有一个返回值，多用于处理数据
			CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型
			BEGIN
				函数体
			END
			CREATE FUNCTION myf1() RETURNS INT
			BEGIN
				DECLARE c INT DEFAULT 0;
				SELECT COUNT(*) INTO c
				FROM employees
				RETURNS c;
			END $
	流程控制结构
		顺序结构
		分支结构
			IF函数
				SELECT IF(表达式1,表达式2，表达式3) ->同三目运算符算法
			CASE
				CASE 变量|表达式|字段					CASE 
				WHEN 要判断的值 THEN 返回的值或语句1;			WHEN 要判断的表达式 THEN 返回的值或语句1;
				WHEN 要判断的值 THEN 返回的值或语句2;			WHEN 要判断的表达式 THEN 返回的值或语句2;
				...										...
				ELSE 返回的值或语句3;							ELSE 返回的值或语句3;
				END	CASE;								END CASE;
				特点
				可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，BEGIN END 中或BEGIN END的外面
				可以作为独立的语句去使用，只能放在BEGIN END中
			IF结构 可实现多重分支
			IF 条件1 then 语句2;
			ELSEIF 条件2 then 语句2;
			...
			[ELSE 语句n;]
			END IF;应用在BEGIN END中
		循环结构
			WHILE LOOP REPEAT
			WHILE 循环条件 DO
				循环体;
			END WHILE[标签];
			CREATE PROCEDURE pro_while1(IN insertCount INT)
			BEGIN
				DECLAR i INT DEFAULT 1;
				a: WHILE i<=insertCount DO
					INSERT INT amin(username,`passsword`) VALUES(CONCAT('Rose'+i),'666');
					IF i>=20 THEN LEAVE a;
					SET i=i+1;
				END WHILE a;
			END;
			[标签:]LOOP 
				循环体;
			END LOOP [标签];
			[标签:]REPEAT
				循环体;
				UNTIL 结束循环的条件;
			END REPEAT {标签};
			循环控制 
				iterate继续，结束本次循环，继续下一次
				leave 跳出，结束当前所在的循环
	mysql高级
		mysql架构
		索引优化分析
		查询截取分析
		mysql锁机制
		主从复制

计算机网络：
	概述
		局域网
			覆盖范围小 自己买设备 带宽固定 自己维护
		广域网
			花钱买带宽
		子网掩码 几个255标志了前几段是网络部分，后面是主机部分
		数据包： 数据+源地址+目标地址 数据帧：再+源mac地址+目标mac地址
			ip地址决定了出发地和终点，mac地址则决定当前位置和下一步位置
			交换机看mac地址，路由器看ip地址
			发数据后接收到会发回确认，然后再发送
		应用层：所有能产生网络流量的程序
		表示层：在传输之气那是否进行加密或压缩处理 二进制ascii
		会话层：
		传输层：可靠传输、流量控制、不可靠传输
		网络层：负责选择最佳路径 规划ip地址
		数据链路层：真的开始和结束 透明传输 差错检验
		物理层：接口标准 电器标准
		OSI参考模型对网络排错指导
			物理层故障：查看连接状态、发送和接收的数据包
			数据链路层故障：mac冲突、adsl欠费、网速不匹配、计算机连接到错误的VLAN
			网络层故障：配置错ip地址、子网掩码、配置错网关、路由器没有配置到达目标网络的路由
			应用层故障：应用程序配置错误
		OSI参考模型和网络安全
			物理层安全
			数据链路层安全 ADSL账号密码、VLAN交换机端口绑定mac地址
			网络层安全
		TCP/IP协议栈
			应用表示会话层 HTTP FTP DNS                                  上层数据
			传输层：TCP/UDP				                          TCP头+          ->数据段或消息       
			网络层：ARP IP ICMP IGMP					     IP头+				  ->数据包
			数据链路 物理层： Ethernet ATM Frame Relay mac头+                     +FCS->数据帧
		计算机网络性能
			速率：主机在数字信道上传送数据位数的速率
			带宽：数字信道所能传送的最高数据率
			吞吐量：单位时间内通过某个网络的吞吐量
			时延：发送时延、传播时延、处理时延、排队时延
			时延带宽积：即线路上有多少数据
			往返时间：RTT(Round-Trip Time)
			网路利用率：信道利用率、网络利用率
	数据链路层
		基本概念
		三个基本问题
			封装成帧 帧首部+IP数据报+帧尾部
				帧开始符SOH			+帧结束符EOT
			透明传输
				若数据中出现控制字符则进行字符填充 +转义字符ESC（十六进制1B）
			差错检验
				循环冗余检验CRC 计算FCS 余数R为0则无差错就接收，1则有差错就丢弃
				不能确定差错具体位置，除数越大，检测不到异常的概率越小
		两种情况
			使用点对点信道：点对点通信
				PPP协议：可以封装成帧、透明传输、多种网络层协议、多种类型链路、差错检测、检测连接状态
				网络层地址协商、数据压缩协商、不能流量控制、不能纠错、不能多点线路
					协议帧格式：首部FAC+协议+信息部分（不超过1500字节）+尾部FCS+F
					透明传输时若为字节流则ESC填充，二进制流则0填充
				信道复用技术：
					频分复用：频分复用的所有主机在相同的时间占用不同的频率带宽资源
					时分复用：时分复用的所有主机在不同的时间占用相同的频率带宽资源
					统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送
					波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波
					码分复用：码分复用需要发送的数据量为原先的 m 倍
			使用广播信道：一对多的广播通信
				CSMA/CD
					以太网采用->动态媒体接入控制多点接入->随机接入
		以太局域网
			以太网提供的服务时不可靠的交付，即尽最大努力的交付
			MAC层：
				硬件地址mac地址
				单播帧、广播帧、多播帧
				Mac帧格式：
					物理层：8字节+ 		        以太网Mac帧
					Mac层：		   目标地址6+源地址6+类型2+数据46-1500+FCS4
					IP层：              			IP数据报
					若mac帧小于64字节则补足成64 抓包时如果校验成功时看不到FCS的
		扩展局域网
			通过交换机实现，交换端口带宽独享 安全 基于mac地址转发 通过学习构建mac表
		高速以太网
	网络层
		网络层提供的服务：
			网络层只负责尽力分发数据包，并不负责管理丢包重传以及顺序
			计算机通信的过程，就是本网段通信跨网段通信的过程
			发送端
				应用程序准备要传输的文件
				传输层 将文件分段并编号
				网络层 添加目标IP地址源IP地址
				数据链路层 两种情况 使用自己的子网掩码 判断自己在那个网段和目标地址在哪个网段
			发送数据的过程
				应用层把数据依次封装成数据帧报帧进入物理层，经交换机存储转发给路由（路由点对点为FF，再
				经过又物理层依次解封装将数据返回给应用层，每一层只能看到本层的数据流动
			ARP协议
				为IP协议提供服务，是数据传输之前的服务
				ARP将IP地址通过广播 目标MAC地址是FF-FF-FF-FF-FF 解析目标IP地址的MAC地址，
				仅在本网段中传播广播包
			ICMP协议
				测试网络层是否畅通 ping命令 Packet Internet Grope
				TTL 生存周期 可以经过多少次路由器 Linux一般64、windows一般128、Unix一般255
				pathping 跟踪数据报路径 计算丢包情况
			IGMP协议
				组播=多播
				路由器扫描本网段有哪些绑定了多播地址，决定是否接收多播数据
				多播不建立会话

​			RARP协议

​				RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。

​			IP数据包结构<img src="C:\Users\hawk4\Desktop\临时\笔记\笔记图片\image-20191215170714885.png" alt="image-20191215170714885" style="zoom:50%;" />

​				数据报最大可以为65535，而数据报可能根据数据链路最大传输单元MTU决定分片：若发送的数据超过1500字节则分片为每个1500字节的数据包进行发送，其中用标识相同的包一个完整数据报的合并，其中标志部分最低位MF(More Fragment)为1时则后面还有分片，为0则是最后一个分片，中间位DF(Don't Fragment),仅当位0时才可以进行分片

​				生存时间TTL Time to live，协议指明数据交给谁处理，ICMP协议号 1，IGMP 2，TCP 6，UDP 17，IPv6 41，OSPF 89

​				总共20字节的固定部分，可选部分1-40字节

​			IP协议

​				网络畅通的条件 数据包有去有回

​		传输层的功能

​			传输层协议

​			TCP协议 需要将传输的文件分段 传输建立会话 可靠传输 流量控制

​			UDP 一个数据包就能完成数据通信 不许要建立会话 不需要流量控制 进行不可靠传输 （多播广播应用

​			查看会话netstat -n

​		传输层协议与应用层协议之间的关系

​            			<img src="C:\Users\hawk4\Desktop\临时\笔记\笔记图片\QQ截图20191215215250.png" alt="QQ截图20191215215250" style="zoom:67%;" />

​				TCP or UDP+端口 可以作为一个协议标识 http=TCP+80  https=TCP+443 PoP3=TCP+110 SQL=TCP+1433

​			服务和应用层协议之间关系

​				服务使用 TCP或UDP的端口侦听客户端请求；客户端使用IP地址定位服务器 使用目标端口定位服务；可以再服务器网卡上设置只开放必要的接口实现服务器网络安全

​			传输层功能 为相互通信的应用进程提供了逻辑通信、对收到的报文进行差错检测、提供面向连接和无连接的服务

​			端口号只有本地意义，不应该冲突，但因特网中不同计算机的相同端口号是没有联系的，端口号0-65535，熟知的端口一般0-1023，登记端口为1024-49151，客户端端口49152-65535 -netstat -n|find "ESTABLISHED"

​		UDP

​			特点：UDP是无连接的，发送数据之前不需要建立连接、尽最大努力交付，不保证可靠交付也不是用拥塞控制、面向报文、支持一对一、一对多、多对一、多对多的交互通信、首部开销小只有8个字节

​			UDP首部格式

<img src="C:\Users\hawk4\Desktop\临时\笔记\笔记图片\QQ截图20191215222754.png" alt="QQ截图20191215222754" style="zoom: 50%;" />

​			伪首部从网络层中提取，剩下8个字节为UDP的真首部

​		TCP

​			特点：TCP是面向连接的传输层协议、每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的，提供可靠交付的服务、提供全双工通信、面向字节流，TCP把连接作为基本的抽象，TCP连接的端点为套接字socket，socket=(IP地址:端口号)，每一条TCP连接唯一地通信两端的两个端点所确定

​			TCP首部格式

​    			           <img src="C:\Users\hawk4\Desktop\临时\笔记\笔记图片\QQ截图20191215231102.png" alt="QQ截图20191215231102" style="zoom: 67%;" /> 

​				 首部不固定，固定部分20字节，后面选项长度可变，序号指本数据包段首为整个数据的第几个字节，而确认号为下次传输的起始数据序号，URG标识数据包紧急程度，ACK为0时确认号有效，为1时无效，SYN为1建立请求，窗口为相互协商的接收发送缓存大小，校验和与UDP一样需要网络层中的信息作为伪首部进行判断，紧急指针指向紧急信息的尾部

​			可靠传输：				

​				ARQ自动重传请求协议：无丢失情况、超时重传、确认丢失、确认迟到，为了提高信道利用率，采用流水线可采用流水线传输

​				连续ARQ协议：滑动窗口实现连续传输，最前沿的数据收到确认后先后滑动

​				累计确认进行优化，通过发送端确认最后一个没有发生丢失的数据作为滑动窗口的位置

<img src="C:\Users\hawk4\Desktop\临时\笔记\笔记图片\QQ截图20191215230818.png" alt="QQ截图20191215230818" style="zoom:67%;" />

​			流量控制：

​				滑动窗口可变，根据接收缓存剩余大小来决定窗口大小，窗口大小为0时停止发送，发送端定时向接收端确认窗口大小，避免了接收端回复消息的丢失

​			拥塞控制：

​				出现资源拥塞的条件 对资源需求的哦在那个和>可用资源 拥塞控制是一个全局性的过程，拥塞避免指用色窗口控制为按线性规律增长，使网络比较不容易出现拥塞

​				慢重传在出现丢包时在最后一个分片数据包的最后一段到达才发送重传请求，而快重传则在出现丢包后立即发送重传请求，快重传配套使用了快恢复，窗口门限从12开始线性增长与慢开始的从1开始指数增长到12不同

​			传输连接管理：

​				TCP连接建立：三次握手

​				第一次握手：客户端发送syn包(syn=1，seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；

​				第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=1，seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

​				第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

​				握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

​				为什么需要三次握手而不是两次https://www.jianshu.com/p/4d39863e62ab

​				TCP连接释放：四次挥手

​				与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。

​				第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。

​				第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
​				第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
​				第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。               

​                         <img src="C:\Users\hawk4\Desktop\临时\笔记\笔记图片\092017231747399.jpg" alt="092017231747399" style="zoom:67%;" />

​		应用层

​			DNS服务作用 负责解析域名 将域名解析成IP

​			域名： 根->顶级域名->二级域名

​			域名解析的过程：DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）、区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

​			DHCP动态主机配置

​				静态IP地址、动态IP地址

​				DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。DHCP 工作过程如下：

​				客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。

​				DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。

​				如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。

​				DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。

​			TELNET远程登陆协议

​				TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。

​			电子邮件协议

​				一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。![电子邮件协议](C:\Users\hawk4\Desktop\临时\笔记\电子邮件协议.png)

​				SMTP：SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则

​				POP3：POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件

​				IMAP：IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件

​			FTP文件传输协议

​				使用两个连接，TCP控制连接端口21和TCP数据连接端口20

​				主动模式 ftp客户端通知FTP服务器使用20端口侦听，FTP服务器和客户端的此端口建立连接 

​				被动模式 FTP服务器打开一个端口，等待客户端发起连接

​				传输模式

​					文本模式：ASCII模式，以文本序列传输数据 二进制模式：Binary模式，以二进制序列传输数据

​			HTTP超文本传输协议 使用TCP连接

​				统一资源定位符 URL 标准格式 <协议>:/?<主机>:<端口>/<路径>

​				超文本标记语言 HTML

​			Web 页面请求过程

​			DHCP 配置主机信息
​				假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。

​				主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。

​				该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。

​				该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。

​				该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。

​				主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

​			ARP 解析 MAC 地址
​				主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。

​				主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。

​				该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。

​				该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。

​				DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。

​				主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。

​				网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

​			DNS 解析域名
​				知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。

​				网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。

​				因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。

​				到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。

​				找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

​			HTTP 请求页面
​				有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。

​				在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。

​				HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。

​				连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。

​				HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。

​				浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

